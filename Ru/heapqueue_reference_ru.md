# Справочник модуля `heapqueue` (Nim)

> Модуль `heapqueue` реализует **двоичную кучу** (binary heap) — структуру данных, которую можно использовать как **очередь с приоритетом** (priority queue).  
> Внутренний массив всегда удовлетворяет инварианту кучи: `a[k] <= a[2*k+1]` и `a[k] <= a[2*k+2]`. Это гарантирует, что **наименьший элемент всегда находится в `heap[0]`**.

---

## Содержание

- [Тип данных](#тип-данных)
- [Инициализация](#инициализация)
- [Добавление элементов](#добавление-элементов)
- [Извлечение элементов](#извлечение-элементов)
- [Комбинированные операции](#комбинированные-операции)
- [Удаление по индексу и очистка](#удаление-по-индексу-и-очистка)
- [Доступ и поиск](#доступ-и-поиск)
- [Размер и итерация](#размер-и-итерация)
- [Прочее](#прочее)
- [Работа с пользовательскими типами](#работа-с-пользовательскими-типами)
- [Краткая шпаргалка](#краткая-шпаргалка)

---

## Тип данных

### `HeapQueue[T]`

Двоичная куча (min-heap), реализованная поверх `seq[T]`. Наименьший элемент всегда доступен как `heap[0]`. Имеет **семантику значений**: оператор `=` создаёт полную копию.

Для работы с пользовательскими типами необходимо реализовать оператор `<`.

```nim
var heap: HeapQueue[int]
```

---

## Инициализация

### `initHeapQueue[T](): HeapQueue[T]`

Создаёт и возвращает новую пустую кучу. Начиная с Nim v0.20, кучи инициализируются автоматически, поэтому явный вызов необязателен.

```nim
var heap = initHeapQueue[int]()
heap.push(5)
heap.push(1)
heap.push(3)
assert heap[0] == 1   # наименьший элемент всегда первый
```

---

### `toHeapQueue[T](x: openArray[T]): HeapQueue[T]`

Создаёт новую кучу из массива или последовательности `x`. Построение кучи выполняется по алгоритму Флойда за **O(n)** — эффективнее, чем n последовательных вызовов `push`.

> Доступно начиная с Nim v1.3.

```nim
var heap = [9, 5, 8, 1, 3].toHeapQueue
assert heap[0] == 1    # наименьший элемент

# Обратите внимание: порядок остальных элементов
# определяется структурой кучи, а не исходным массивом
assert heap.pop() == 1
assert heap.pop() == 3
assert heap.pop() == 5
```

---

## Добавление элементов

### `push[T](heap: var HeapQueue[T], item: sink T)`

Добавляет элемент `item` в кучу, сохраняя инвариант. Сложность: **O(log n)**.

```nim
var heap = initHeapQueue[int]()
heap.push(10)
heap.push(2)
heap.push(7)
heap.push(1)
assert heap[0] == 1   # наименьший всегда в корне

# Добавление в цикле:
var h = initHeapQueue[string]()
for word in ["banana", "apple", "cherry"]:
  h.push(word)
assert h[0] == "apple"
```

---

## Извлечение элементов

### `pop[T](heap: var HeapQueue[T]): T`

Извлекает и возвращает **наименьший** элемент из кучи, сохраняя инвариант. Сложность: **O(log n)**.

> ⚠️ Вызов на пустой куче приведёт к ошибке (паника или некорректное поведение).

```nim
var heap = [9, 5, 8, 1, 3].toHeapQueue

# Элементы извлекаются в порядке возрастания:
assert heap.pop() == 1
assert heap.pop() == 3
assert heap.pop() == 5
assert heap.pop() == 8
assert heap.pop() == 9

# Паттерн «сортировка через кучу»:
var h = [3, 1, 4, 1, 5, 9, 2, 6].toHeapQueue
var sorted: seq[int]
while h.len > 0:
  sorted.add(h.pop())
assert sorted == @[1, 1, 2, 3, 4, 5, 6, 9]
```

---

## Комбинированные операции

### `replace[T](heap: var HeapQueue[T], item: sink T): T`

Атомарно извлекает текущий наименьший элемент и добавляет `item` на его место. Эффективнее, чем `pop()` + `push()`, поскольку требует только одного прохода просеивания.

> ⚠️ Возвращаемое значение **может быть больше** `item`. Убедитесь, что это допустимо в вашей логике.

```nim
var heap = [5, 12, 20].toHeapQueue
let old = heap.replace(6)
assert old == 5       # был извлечён наименьший
assert heap.len == 3  # размер не изменился
assert heap[0] == 6   # 6 теперь новый минимум

# Случай, когда результат > item:
let old2 = heap.replace(4)
assert old2 == 6      # извлечён текущий минимум (6)
assert heap[0] == 4   # 4 стал новым минимумом
```

---

### `pushpop[T](heap: var HeapQueue[T], item: sink T): T`

Быстрая версия `push()` + `pop()`. Добавляет `item` и немедленно возвращает наименьший из всех элементов (включая новый). Размер кучи не изменяется.

Если `item` меньше или равен текущему минимуму, он возвращается сразу, без изменения кучи.

```nim
var heap = [5, 12].toHeapQueue

# 6 > 5, поэтому возвращается текущий минимум (5), 6 добавляется:
assert heap.pushpop(6) == 5
assert heap[0] == 6

# 4 < 6 (текущий минимум), поэтому 4 возвращается сразу:
assert heap.pushpop(4) == 4
assert heap[0] == 6   # куча не изменилась
```

**Отличие от `replace`:**

| | `replace(item)` | `pushpop(item)` |
|---|---|---|
| Возвращает | текущий минимум (всегда) | `min(текущий_мин, item)` |
| Когда item < мин | item входит, старый мин выходит | item выходит сразу, куча не меняется |
| Типичное применение | замена наименьшего элемента | фильтрация потока данных |

---

## Удаление по индексу и очистка

### `del[T](heap: var HeapQueue[T], index: Natural)`

Удаляет элемент по произвольному индексу `index`, сохраняя инвариант кучи. Сложность: **O(log n)**.

Индекс получают с помощью `find`. Не путайте: после `del` индексы остальных элементов могут измениться.

```nim
var heap = [9, 5, 8].toHeapQueue
# heap[0] == 5, heap[1] == 9, heap[2] == 8

heap.del(1)   # удаляем элемент с индексом 1 (это 9)
assert heap.len == 2
assert heap[0] == 5

# Типичный паттерн: найти и удалить конкретное значение:
var h = [10, 30, 20, 40].toHeapQueue
let idx = h.find(30)
if idx >= 0:
  h.del(idx)
```

---

### `clear[T](heap: var HeapQueue[T])`

Удаляет все элементы из кучи. Сложность: O(1) (сбрасывает длину внутреннего `seq`).

```nim
var heap = [9, 5, 8].toHeapQueue
assert heap.len == 3
heap.clear()
assert heap.len == 0
```

---

## Доступ и поиск

### `heap[i: Natural]: lent T`  — оператор `[]`

Возвращает элемент по индексу `i` во внутреннем массиве кучи. `heap[0]` — всегда наименьший элемент. Остальные индексы **не соответствуют** отсортированному порядку.

```nim
let heap = [9, 5, 8, 1].toHeapQueue
assert heap[0] == 1   # наименьший
# heap[1], heap[2], heap[3] — в порядке кучи, не по возрастанию
```

---

### `find[T](heap: HeapQueue[T], x: T): int`

Линейный поиск элемента `x`. Возвращает его **индекс** во внутреннем массиве, или `-1` если не найден. Сложность: **O(n)**.

> Доступно начиная с Nim v1.3.

```nim
let heap = [9, 5, 8].toHeapQueue
assert heap.find(5) == 0    # 5 — наименьший, индекс 0
assert heap.find(9) == 1
assert heap.find(777) == -1  # не найден
```

---

### `contains[T](heap: HeapQueue[T], x: T): bool`

Возвращает `true`, если `x` присутствует в куче. Эквивалент `find(heap, x) >= 0`. Поддерживает синтаксис `in` / `notin`. Сложность: **O(n)**.

> Доступно начиная с Nim v2.1.1.

```nim
let heap = [9, 5, 8].toHeapQueue
assert 5 in heap
assert heap.contains(8)
assert 42 notin heap
```

---

## Размер и итерация

### `len[T](heap: HeapQueue[T]): int`

Возвращает количество элементов в куче. Сложность: O(1).

```nim
let heap = [9, 5, 8].toHeapQueue
assert heap.len == 3
```

---

### `items[T](heap: HeapQueue[T]): lent T`  (итератор)

Перебирает все элементы кучи в **порядке внутреннего массива** (не в порядке возрастания!). Запрещено изменять кучу во время итерации.

> Доступно начиная с Nim v2.1.1.

```nim
let heap = [5, 9, 8, 1, 3].toHeapQueue
for x in heap:
  echo x   # порядок определяется структурой кучи

# Чтобы обойти в отсортированном порядке — используйте pop в цикле:
var h = [5, 9, 8, 1, 3].toHeapQueue
while h.len > 0:
  echo h.pop()   # 1, 3, 5, 8, 9
```

---

## Прочее

### `$[T](heap: HeapQueue[T]): string`

Преобразует кучу в строковое представление вида `[e1, e2, e3]`. Порядок элементов соответствует внутреннему массиву. Для отладки и вывода.

```nim
let heap = [1, 2].toHeapQueue
echo $heap   # [1, 2]

let h = [9, 5, 8].toHeapQueue
echo $h      # [5, 9, 8] — порядок кучи, не отсортированный
```

---

## Работа с пользовательскими типами

Для использования `HeapQueue` с объектами необходимо реализовать оператор `<`. Именно он определяет порядок в куче (наименьший с точки зрения `<` будет в корне).

```nim
type Task = object
  priority: int
  name: string

# Чем меньше priority, тем выше приоритет задачи:
proc `<`(a, b: Task): bool = a.priority < b.priority

var tasks = initHeapQueue[Task]()
tasks.push(Task(priority: 3, name: "Low"))
tasks.push(Task(priority: 1, name: "Critical"))
tasks.push(Task(priority: 2, name: "Normal"))

assert tasks[0].name == "Critical"   # наивысший приоритет
assert tasks.pop().name == "Critical"
assert tasks.pop().name == "Normal"
assert tasks.pop().name == "Low"
```

```nim
# Обратный порядок (max-heap через обёртку):
type MaxInt = object
  val: int

proc `<`(a, b: MaxInt): bool = a.val > b.val   # инвертированное сравнение

var maxHeap = initHeapQueue[MaxInt]()
maxHeap.push(MaxInt(val: 3))
maxHeap.push(MaxInt(val: 7))
maxHeap.push(MaxInt(val: 1))
assert maxHeap[0].val == 7   # наибольший теперь в корне
```

---

## Краткая шпаргалка

| Операция | Процедура | Сложность |
|---|---|---|
| Создать пустую кучу | `initHeapQueue[T]()` | O(1) |
| Создать из массива | `toHeapQueue(arr)` | O(n) |
| Добавить элемент | `push(item)` | O(log n) |
| Извлечь минимум | `pop()` | O(log n) |
| Посмотреть минимум | `heap[0]` | O(1) |
| Заменить минимум | `replace(item)` | O(log n) |
| Добавить и извлечь | `pushpop(item)` | O(log n) |
| Удалить по индексу | `del(index)` | O(log n) |
| Найти индекс | `find(x)` | O(n) |
| Проверить наличие | `contains(x)` / `in` | O(n) |
| Количество элементов | `len()` | O(1) |
| Очистить | `clear()` | O(1) |
| Итерация | `items` / `for x in heap` | O(n) |
| Строка | `$` | O(n) |

### Инвариант кучи

```
           1  (индекс 0 — всегда минимум)
          / \
         3   5  (индексы 1, 2)
        / \ / \
       9  4 8  7  (индексы 3, 4, 5, 6)

a[k] <= a[2*k+1]  и  a[k] <= a[2*k+2]
```

### Примечания

- `HeapQueue` является **min-heap**: `pop()` всегда возвращает **наименьший** элемент.
- Для **max-heap** инвертируйте оператор `<` в своём типе.
- Итерация через `items` даёт элементы в **порядке внутреннего массива**, а не по возрастанию. Для отсортированного обхода используйте `pop()` в цикле.
- Не вызывайте `pop()` или `replace()` на пустой куче.
- `replace` эффективнее пары `pop` + `push`; `pushpop` эффективнее пары `push` + `pop`.
