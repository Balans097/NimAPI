# std/strformat — справочник по модулю

> Интерполяция и форматирование строк в Nim, вдохновлённые f-строками Python.
> Всё разворачивается на **этапе компиляции** через макросы — никаких накладных расходов на разбор строк в рантайме.

---

## Содержание

1. [Ключевые концепции](#ключевые-концепции)
2. [Шаблон `fmt`](#шаблон-fmt)
3. [Оператор `&`](#оператор-)
4. [fmt против & — критическая разница](#fmt-против----критическая-разница)
5. [Синтаксис спецификатора формата](#синтаксис-спецификатора-формата)
6. [Выравнивание и заливка](#выравнивание-и-заливка)
7. [Управление знаком](#управление-знаком)
8. [Форматирование целых чисел](#форматирование-целых-чисел)
9. [Форматирование вещественных чисел](#форматирование-вещественных-чисел)
10. [Форматирование строк](#форматирование-строк)
11. [Режим отладки — `expr=`](#режим-отладки--expr)
12. [Произвольные выражения в фигурных скобках](#произвольные-выражения-в-фигурных-скобках)
13. [Пользовательские разделители](#пользовательские-разделители)
14. [Расширение форматирования — `formatValue`](#расширение-форматирования--formatvalue)
15. [`alignString`](#alignstring)
16. [`parseStandardFormatSpecifier`](#parsestandardformatspecifier)
17. [`StandardFormatSpecifier`](#standardformatspecifier)
18. [Экранирование фигурных скобок](#экранирование-фигурных-скобок)
19. [Ограничения](#ограничения)
20. [Шпаргалка](#шпаргалка)

---

## Ключевые концепции

`std/strformat` преобразует строковые литералы с заполнителями `{выражение}` в эффективный код построения строк на этапе компиляции. Компилятор разворачивает каждую форматную строку в последовательность вызовов `add` на предварительно выделенном буфере — никакого разбора строк в рантайме не происходит.

Модуль предоставляет два инструмента:

- **`fmt`** — шаблон/макрос, принимающий *сырой строковый литерал* (обратные слэши не интерпретируются как escape-последовательности).
- **`&`** — унарный оператор, принимающий *обычный строковый литерал* (escape-последовательности работают).

Оба разворачиваются в один и тот же внутренний механизм, но escape-поведение их строковых литералов принципиально различается (см. [fmt против &](#fmt-против----критическая-разница)).

---

## Шаблон `fmt`

```nim
template fmt*(pattern: static string): string
template fmt*(pattern: static string; openChar: static char, closeChar: static char): string
```

Интерполирует `pattern`, используя переменные и выражения, видимые в текущей области видимости. `pattern` должен быть **константой времени компиляции** (литерал или `const`).

Поскольку `fmt"..."` — это *обобщённый сырой строковый литерал*, такие последовательности как `\n` **не интерпретируются** — обратный слэш сохраняется в выводе буквально.

```nim
let name = "Алиса"
let score = 98.5

echo fmt"Игрок: {name}, Очки: {score:.1f}"
# Игрок: Алиса, Очки: 98.5

const шаблон = "Привет, {name}!"
echo шаблон.fmt
# Привет, Алиса!

# fmt использует сырой литерал — \n это буквальный бэкслэш и n
echo fmt"{name}\n"
# Алиса\n     ← это НЕ перенос строки!
```

---

## Оператор `&`

```nim
template `&`*(pattern: string{lit}): string
```

Унарный префиксный оператор, полностью эквивалентный `pattern.fmt`. Ключевое отличие от `fmt"..."`: `&"..."` принимает **обычный строковый литерал**, поэтому escape-последовательности `\n`, `\t`, `\"` обрабатываются лексером Nim до того, как макрос увидит строку.

```nim
let name = "Алиса"

echo &"{name}\n"
# Алиса        ← за ним следует настоящий перенос строки

echo &"Таб:\tздесь"
# Таб:	здесь   ← настоящий символ табуляции
```

Используйте `&`, когда форматная строка должна содержать переносы строк, табуляции или другие escape-последовательности вместе с интерполяцией.

---

## fmt против & — критическая разница

Это самый распространённый источник путаницы в модуле.

| Свойство | `fmt"..."` | `&"..."` |
|---|---|---|
| Вид литерала | Сырой (обобщённый raw-литерал) | Обычный |
| `\n` в паттерне | Буквальный `\n` (два символа) | Настоящий перенос строки |
| `\t` в паттерне | Буквальный `\t` (два символа) | Настоящая табуляция |
| Интерполяция | Да | Да |
| Время компиляции | Да | Да |

```nim
let x = "hello"

# fmt — сырой литерал, \n остаётся как бэкслэш-n
assert fmt"{x}\n" == "hello\\n"

# & — обычный литерал, \n становится настоящим переносом строки
assert &"{x}\n" == "hello\n"

# Способы получить и переносы, и fmt:
assert fmt"{x}{'\n'}"   == "hello\n"  # встроить символьный литерал
assert fmt("{x}\n")     == "hello\n"  # синтаксис вызова — обычный литерал
assert "{x}\n".fmt      == "hello\n"  # метод-синтаксис — обычный литерал
```

**Правило:** если в форматной строке нужны реальные управляющие символы, используйте `&`. Если используете `fmt` и нужен перенос строки, вставьте его как `{'\n'}` или используйте синтаксис вызова/метода.

---

## Синтаксис спецификатора формата

Внутри `{выражение}` необязательное двоеточие с *спецификатором формата* управляет тем, как значение будет отображено:

```
{выражение}            ← форматирование по умолчанию
{выражение:спецификатор} ← пользовательское форматирование
```

Общая грамматика спецификатора:

```
[[fill]align][sign][#][0][minimumwidth][.precision][type]
```

Каждый компонент необязателен. Они применяются слева направо.

---

## Выравнивание и заливка

`[fill]align` управляет тем, как значение дополняется до `minimumwidth`.

**Символ выравнивания** (`align`):

| Символ | Смысл | По умолчанию для |
|---|---|---|
| `<` | По левому краю | строк |
| `>` | По правому краю | чисел |
| `^` | По центру | — |

Необязательный **символ заливки** (`fill`) — любой одиночный символ перед `align` — используется для дополнения вместо пробела.

```nim
# Правое выравнивание в поле шириной 8 (по умолчанию для чисел)
assert fmt"{42:8}"    == "      42"

# Явное левое выравнивание
assert fmt"{42:<8}"   == "42      "

# По центру
assert fmt"{42:^8}"   == "   42   "

# Нестандартный символ заливки
assert fmt"{42:0>6}"  == "000042"    # нули, правое выравнивание

# Строки по умолчанию выровнены по левому краю
assert &"""{"abc":>6}""" == "   abc"  # правое выравнивание строки
assert &"""{"abc":^6}""" == " abc  "  # по центру
```

---

## Управление знаком

Компонент `sign` применяется только к **числовым** значениям.

| Символ | Смысл |
|---|---|
| `+` | Всегда показывать знак (и для положительных, и для отрицательных) |
| `-` | Знак только для отрицательных (по умолчанию) |
| ` ` (пробел) | Пробел перед положительными числами, `-` перед отрицательными |

```nim
assert fmt"{42:+}"  == "+42"
assert fmt"{42:-}"  == "42"
assert fmt"{42: }"  == " 42"
assert fmt"{-42:+}" == "-42"
assert fmt"{-42: }" == "-42"
```

---

## Форматирование целых чисел

Символ `type` для целых чисел выбирает основание системы счисления:

| Тип | Смысл |
|---|---|
| `d` или (ничего) | Десятичное (основание 10) |
| `b` | Двоичное (основание 2) |
| `o` | Восьмеричное (основание 8) |
| `x` | Шестнадцатеричное, строчные буквы |
| `X` | Шестнадцатеричное, прописные буквы |

Флаг `#` автоматически добавляет префикс основания (`0b`, `0o`, `0x`).

Флаг `0` включает дополнение нулями (эквивалент `fill=0, align=>`).

```nim
let n = 255

assert fmt"{n}"      == "255"        # десятичное (по умолчанию)
assert fmt"{n:d}"    == "255"        # явное десятичное
assert fmt"{n:b}"    == "11111111"   # двоичное
assert fmt"{n:o}"    == "377"        # восьмеричное
assert fmt"{n:x}"    == "ff"         # шестнадцатеричное строчными
assert fmt"{n:X}"    == "FF"         # шестнадцатеричное прописными
assert fmt"{n:#x}"   == "0xff"       # шестнадцатеричное с префиксом
assert fmt"{n:#b}"   == "0b11111111" # двоичное с префиксом
assert fmt"{n:08}"   == "00000255"   # дополнение нулями до 8 символов
assert fmt"{n:>10}"  == "       255" # правое выравнивание в поле 10

# Отрицательные числа и дополнение нулями
assert fmt"{-12345:08}" == "-0012345"
assert fmt"{-1:03}"     == "-01"
assert fmt"{-1:3}"      == " -1"
```

---

## Форматирование вещественных чисел

Символ `type` для вещественных чисел выбирает нотацию:

| Тип | Смысл |
|---|---|
| `f` / `F` | Фиксированная точка |
| `e` / `E` | Научная (экспоненциальная) нотация |
| `g` / `G` | Общий формат: фиксированная, если число не слишком большое, иначе научная |
| (ничего) | Как `g`, но всегда показывает хотя бы одну цифру после запятой |

Компонент `.precision` задаёт количество знаков после запятой (для `f`, `e`) или общее количество значимых цифр (для `g`).

```nim
let f = 123.456

assert fmt"{f}"          == "123.456"
assert fmt"{f:.2f}"      == "123.46"         # 2 знака после запятой
assert fmt"{f:9.3f}"     == "  123.456"      # ширина 9, 3 знака
assert fmt"{f:<9.4f}"    == "123.4560 "      # левое выравнивание, 4 знака
assert fmt"{f:>9.0f}"    == "     123."      # 0 знаков после запятой
assert fmt"{f:e}"        == "1.234560e+02"   # научная нотация
assert fmt"{f:>13e}"     == " 1.234560e+02"  # правое выравнивание + научная
assert fmt"{f:.5g}"      == "123.46"         # 5 значимых цифр

# Знак с вещественными числами
assert fmt"{1.5:+.1f}"  == "+1.5"
assert fmt"{-1.5:+.1f}" == "-1.5"

# Дополнение нулями
assert fmt"{1.5:08.2f}" == "00001.50"
```

---

## Форматирование строк

Для строковых значений компонент `precision` ограничивает строку указанным количеством кодовых точек Unicode (не байт). Допустимый символ типа — `s` или его отсутствие.

```nim
let s = "Привет, мир"

assert fmt"{s}"      == "Привет, мир"
assert fmt"{s:.7}"   == "Привет,"     # обрезка до 7 кодовых точек
assert fmt"{s:>15}"  == "    Привет, мир"  # правое выравнивание в 15
assert fmt"{s:<15}"  == "Привет, мир    "  # левое выравнивание
assert fmt"{s:^15}"  == "  Привет, мир  "  # по центру
```

---

## Режим отладки — `expr=`

Добавление `=` после имени выражения в фигурных скобках выводит как исходный текст выражения, так и его значение. Это незаменимо для быстрой отладки без введения отдельных операторов `echo`.

```
{expr=}            → "expr=<значение>"
{expr=:спецификатор} → "expr=<форматированное значение>"
```

Пробелы вокруг `=` сохраняются в выводе дословно, что даёт точный контроль над внешним видом разделителя.

```nim
let x = 42
let name = "Боб"

assert fmt"{x=}"          == "x=42"
assert fmt"{x = }"        == "x = 42"      # пробелы вокруг = сохраняются
assert fmt"{x=:08}"       == "x=00000042"  # спецификатор после =

let pi = 3.14159
assert fmt"{pi=:.2f}"     == "pi=3.14"

proc double(n: int): int = n * 2
assert fmt"{double(x) = }" == "double(x) = 84"
assert fmt"{x.double = }"  == "x.double = 84"
```

---

## Произвольные выражения в фигурных скобках

Между фигурными скобками может стоять любое корректное Nim-выражение — не только имена переменных. Сюда входят арифметика, вызовы функций и методов, условные выражения и даже блочные выражения `block`.

```nim
let a = 10
let b = 3

assert fmt"{a + b}"        == "13"
assert fmt"{a * b - 1}"    == "29"
assert fmt"{a div b}"      == "3"

# Условное выражение
assert fmt"{(if a > b: \"да\" else: \"нет\")}" == "да"

# Вызов функции
import std/strutils
assert fmt"{'hello'.toUpperAscii}" == "HELLO"

# Двоеточие внутри скобок НЕ нужно экранировать
let x = 3.14
assert fmt"{(if x != 0: 1.0/x else: 0):.5}" == "0.31847"

# Блочное выражение (многострочная логика внутри форматной строки)
assert fmt"""{(block:
  var res = ""
  for i in 1..5:
    res &= $i & " "
  res.strip)}""" == "1 2 3 4 5"
```

---

## Пользовательские разделители

По умолчанию `fmt` использует `{` и `}` как открывающий и закрывающий разделители. Оба можно переопределить статическими символьными аргументами — это удобно, когда содержимое само по себе содержит много фигурных скобок (например, JSON, CSS).

```nim
let x = 7

# Использование < и > в качестве разделителей
assert "<x>".fmt('<', '>') == "7"
assert "<<<x>>>".fmt('<', '>') == "<7>"   # << >> — экранирование

# Использование обратного апострофа как открывающего и закрывающего
assert "`x`".fmt('`', '`') == "7"
```

Чтобы вставить буквальный разделитель в вывод, удвойте его — `<<` даёт `<`, когда `<` является открывающим разделителем.

---

## Экранирование фигурных скобок

Чтобы включить буквальную `{` или `}` в вывод, удвойте символ в форматной строке:

```nim
assert fmt"{{" == "{"
assert fmt"}}" == "}"
assert fmt"{{x}}" == "{x}"      # буквальные скобки, не интерполяция
assert fmt"{{{42}}}" == "{42}"  # скобка + значение + скобка
```

Внутри выражения в фигурных скобках символы `{` и `}` как часть синтаксиса Nim (например, в конструкторе таблицы) нужно экранировать обратным слэшем:

```nim
# Передача табличного литерала в $() внутри форматного выражения
assert fmt"""{ $(\{x:1,"world":2\}) }""" == """[("hello", 1), ("world", 2)]"""
```

---

## Расширение форматирования — `formatValue`

`fmt` и `&` делегируют всю реальную работу по рендерингу открытому семейству перегрузок `formatValue`. Чтобы сделать собственный тип форматируемым, достаточно определить:

```nim
proc formatValue(result: var string; value: ВашТип; specifier: string)
```

Эта перегрузка будет автоматически найдена макросом при появлении значения `ВашТип` в форматной строке.

```nim
type Point = object
  x, y: float

proc formatValue(result: var string; p: Point; specifier: string) =
  result.add fmt"({p.x:.2f}, {p.y:.2f})"

let p = Point(x: 1.5, y: -3.0)
echo &"Точка: {p}"
# Точка: (1.50, -3.00)
```

Встроенные перегрузки существуют для `SomeInteger`, `SomeFloat`, `string`, `char` и `cstring`. Для любого другого типа `formatValue` по умолчанию вызывает `$` на значении, а затем форматирует получившуюся строку.

---

## `alignString`

```nim
proc alignString*(s: string, minimumWidth: int; align = '\0'; fill = ' '): string
```

Вспомогательная функция, которая дополняет строку `s` до как минимум `minimumWidth` символов с помощью `fill` согласно флагу `align` (`<`, `>`, `^` или `'\0'` для правого выравнивания по умолчанию). Это низкоуровневый строительный блок, предназначенный для авторов пользовательских реализаций `formatValue`, которым нужно соблюдать те же правила выравнивания, что и встроенные типы.

```nim
assert alignString("hi", 8)          == "      hi"  # по умолчанию правое
assert alignString("hi", 8, '<')     == "hi      "  # левое
assert alignString("hi", 8, '^')     == "   hi   "  # центр
assert alignString("hi", 8, '<', '-') == "hi------"  # нестандартная заливка
```

---

## `parseStandardFormatSpecifier`

```nim
proc parseStandardFormatSpecifier*(s: string; start = 0;
                                   ignoreUnknownSuffix = false): StandardFormatSpecifier
```

Разбирает строку со спецификатором формата (часть после двоеточия в `{expr:спецификатор}`) и возвращает объект `StandardFormatSpecifier`. Необязательный параметр `start` позволяет начать разбор с произвольного смещения в `s`. Если `ignoreUnknownSuffix = true`, неизвестные символы после распознанных полей молча игнорируются вместо вызова `ValueError`.

Предназначена для авторов пользовательских proc `formatValue`, которые хотят поддержать тот же синтаксис спецификаторов, что и встроенные типы — разобрать спецификатор один раз, затем использовать поля результирующего объекта.

```nim
let spec = parseStandardFormatSpecifier(">10.3f")
assert spec.align        == '>'
assert spec.minimumWidth == 10
assert spec.precision    == 3
assert spec.typ          == 'f'
```

---

## `StandardFormatSpecifier`

```nim
type StandardFormatSpecifier* = object
  fill*:          char  # символ заливки (по умолчанию: пробел)
  align*:         char  # '<', '>', '^' или '\0'
  sign*:          char  # '+', '-' или ' '
  alternateForm*: bool  # true, если присутствовал '#'
  padWithZero*:   bool  # true, если присутствовал префикс '0'
  minimumWidth*:  int   # 0 означает «без минимума»
  precision*:     int   # -1 означает «не задана»
  typ*:           char  # 'f', 'g', 'e', 'd', 'x' и т.д., или '\0'
  endPosition*:   int   # индекс в исходной строке после последнего разобранного символа
```

Структурное представление разобранного спецификатора формата. Все поля экспортированы и доступны напрямую после вызова `parseStandardFormatSpecifier`. Пользовательские реализации `formatValue` считывают эти поля, чтобы воспроизвести то же поведение выравнивания и форматирования чисел, что и встроенные типы.

---

## Ограничения

### Параметры шаблонов не интерполируются

Поскольку `fmt`/`&` — макросы, они разворачиваются на этапе компиляции и разрешают идентификаторы из лексической области видимости места вызова. Параметры шаблона подставляются на *другой* стадии расширения — уже после того, как макрос зафиксировал известные ему идентификаторы. В результате имя параметра шаблона внутри форматной строки не разрешается:

```nim
# ЭТО НЕ РАБОТАЕТ:
template myTemplate(arg: untyped): untyped =
  echo &"--- {arg} ---"   # `arg` не виден & в момент раскрытия макроса

# Обходной путь: привязать аргумент к новой локальной переменной
template myTemplate(arg: untyped): untyped =
  block:
    let arg1 {.inject.} = arg
    echo &"--- {arg1} ---"
```

Прагма `{.inject.}` необходима из-за гигиеничности шаблонов; обёртка в `block` предотвращает утечку `arg1` в область вызова.

### Принимаются только строковые литералы

`fmt` и `&` требуют **константы времени компиляции**. Нельзя построить форматную строку в рантайме и передать её в `fmt`:

```nim
let pattern = "{x}"    # переменная рантайма
# echo fmt(pattern)   ← ошибка компиляции: не static string
```

Для форматных строк рантайма нужен другой подход — например, ручная замена с `strutils.replace`.

---

## Шпаргалка

### Грамматика спецификатора

```
{expr}
{expr:[[fill]align][sign][#][0][width][.precision][type]}
{expr=}              ← отладка: выводит "expr=значение"
{expr=:спецификатор} ← отладка с форматом
```

### Выравнивание

| Спецификатор | Эффект |
|---|---|
| `{v:10}` | Правое выравнивание в поле 10 (по умолчанию для чисел) |
| `{v:<10}` | Левое выравнивание в поле 10 (по умолчанию для строк) |
| `{v:^10}` | По центру в поле 10 |
| `{v:*^10}` | По центру, заливка `*` |
| `{v:010}` | Дополнение нулями до ширины 10 |

### Целые числа

| Спецификатор | Пример вывода |
|---|---|
| `{255:d}` или `{255}` | `255` |
| `{255:b}` | `11111111` |
| `{255:o}` | `377` |
| `{255:x}` | `ff` |
| `{255:X}` | `FF` |
| `{255:#x}` | `0xff` |
| `{-1:05}` | `-0001` |

### Вещественные числа

| Спецификатор | Пример вывода |
|---|---|
| `{1.5:.2f}` | `1.50` |
| `{1.5:e}` | `1.500000e+00` |
| `{1.5:.3g}` | `1.5` |
| `{1.5:+.1f}` | `+1.5` |
| `{1.5:08.2f}` | `00001.50` |

### Строки

| Спецификатор | Пример вывода |
|---|---|
| `{"hi":>10}` | `        hi` |
| `{"hi":<10}` | `hi        ` |
| `{"hello":.3}` | `hel` |

### Экранирование и разделители

| Паттерн | Вывод |
|---|---|
| `fmt"{{"` | `{` |
| `fmt"}}"` | `}` |
| `"x".fmt('<','>')` | использует `<` `>` как разделители |

### Ключевые процедуры

| Имя | Назначение |
|---|---|
| `fmt"..."` | Форматирование с сырым строковым литералом (без escape) |
| `&"..."` | Форматирование с обычным литералом (escape работают) |
| `alignString(s, w, align, fill)` | Дополнить строку до минимальной ширины |
| `parseStandardFormatSpecifier(s)` | Разобрать строку спецификатора в структуру |
| `formatValue(result, value, spec)` | Низкоуровневый хук — переопределить для своих типов |
