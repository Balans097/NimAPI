# Справочник по модулю `asyncmacro`

> **Модуль:** `asyncmacro`  
> **Источник:** Стандартная библиотека Nim — `(c) Copyright 2015 Dominik Picheta`  
> **Назначение:** Предоставляет макросы `async`, `await` и `multisync`, на которых построена асинхронная модель Nim поверх `asyncdispatch`.

---

## Обзор

В Nim нет встроенного синтаксиса корутин. Вместо этого асинхронный код пишется в обычном процедурном стиле, а затем **преобразуется на этапе компиляции** макросами из этого модуля. Когда вы пишете `proc fetchData(): Future[string] {.async.}`, компилятор никогда не увидит обычную процедуру — макрос `async` перепишет её в замыкание-итератор, которое `asyncdispatch` может возобновлять каждый раз, когда ожидаемый `Future` завершается.

Понимание этого модуля помогает:
- Разобраться, что реально делают `async` и `await` (и почему некоторые конструкции не компилируются).
- Использовать `multisync`, чтобы одним телом процедуры покрыть оба режима — синхронный и асинхронный.
- Избежать распространённых ловушек: `discardable` на async-процедурах, `await` вне async-контекста и т. д.

---

## Экспортируемые символы

Модуль экспортирует три публичных символа для прямого использования:

| Символ | Вид | Назначение |
|--------|-----|-----------|
| `async` | макрос | Преобразует процедуру в асинхронный замыкающий итератор |
| `await` | шаблон (×2) | Приостанавливает async-процедуру до завершения `Future` |
| `multisync` | макрос | Генерирует синхронную и асинхронную версии из одного тела |

---

## `async`

### Что делает

`async` — это **макрос времени компиляции**, который вы прикрепляете к процедуре как pragma. Он выполняет глубокое преобразование AST: всё тело процедуры переписывается в **замыкающий итератор** (closure iterator), который уступает управление циклу событий каждый раз, когда встречает выражение `await`.

Внутри `async` делает следующее:
1. Проверяет, что возвращаемый тип — `Future[T]` (или пустой, который становится `Future[void]`).
2. Переписывает операторы `return` в вызовы `complete()` на скрытом возвращаемом `Future`.
3. Оборачивает тело в замыкающий итератор, который возвращает `FutureBase`.
4. Создаёт callback (`createCb`), заново запускающий итератор при каждом завершении ожидаемого `Future`.
5. Выделяет `newFuture[T]()`, запускает итератор и возвращает этот `Future` вызывающей стороне.

В результате каждая async-процедура снаружи выглядит как обычная функция, немедленно возвращающая `Future`. Внутри она — конечный автомат, управляемый циклом событий.

### Сигнатура

```nim
macro async*(prc: untyped): untyped
```

`async` можно применять к одиночной процедуре, методу, лямбде или блоку `do`. Также принимает `stmtList` из нескольких процедур (при использовании как блочной прагмы).

### Правила и ограничения

- Тип возврата **должен** быть `Future[T]` или опущен (трактуется как `Future[void]`).
- Прагма `discardable` **запрещена** — futures нужно проверять через `asyncCheck`, а не молча отбрасывать.
- Вложенные определения процедур/методов внутри async-тела остаются нетронутыми (сами не становятся асинхронными).
- Отладочный вывод раскрытого макроса включается флагом `-d:nimDumpAsync`.

### Примеры

#### Базовая async-процедура

```nim
import asyncdispatch

proc greet(name: string): Future[string] {.async.} =
  # Имитируем задержку ввода-вывода без блокировки потока
  await sleepAsync(100)
  return "Привет, " & name

# Вызов greet() НЕ блокирует — немедленно возвращает Future.
let fut = greet("Мир")
echo waitFor fut   # → "Привет, Мир"
```

Макрос `async` превращает `greet` в замыкающий итератор. Строка `return "Привет, " & name` перезаписывается в вызов `complete(retFuture, "Привет, " & name)` перед возвратом `nil` из итератора.

#### Async-процедура, возвращающая void

```nim
proc logEvent(msg: string): Future[void] {.async.} =
  await sleepAsync(10)
  echo "[LOG] " & msg

# Эквивалент — опустить тип возврата тоже даёт Future[void]:
proc logEvent2(msg: string) {.async.} =
  await sleepAsync(10)
  echo "[LOG] " & msg
```

#### Применение к лямбде

```nim
let handler = proc (data: string): Future[void] {.async.} =
  await sleepAsync(5)
  echo "получено: " & data

asyncCheck handler("ping")
runForever()
```

#### Несколько async-процедур в одном блоке (форма stmtList)

```nim
{.async.}:
  proc fetchA(): Future[string] =
    return "A"
  proc fetchB(): Future[string] =
    return "B"
```

---

## `await`

### Что делает

`await` — это **шаблон** (два перегруженных шаблона), который приостанавливает текущую async-процедуру до завершения `Future[T]`, а затем распаковывает и возвращает его значение (или поднимает хранящееся исключение).

Два варианта перегрузки:

1. **`await[T](f: Future[T]): auto`** — основной вариант. Внутри async-процедуры компилируется в `yield` лежащего в основе `FutureBase`, что возвращает управление циклу событий. Когда future завершается, итератор возобновляется и вызывается `f.read()` для получения значения (или повторного подъёма исключения).

2. **`await(f: typed): untyped`** — запасной вариант, срабатывающий как `static: error`, если `f` не является `Future[T]`. Даёт понятное сообщение об ошибке компиляции вместо запутанной ошибки типов.

Использование `await` вне async-процедуры вызывает ошибку компиляции с советом использовать `waitFor`.

### Сигнатура

```nim
template await*[T](f: Future[T]): auto
template await*(f: typed): untyped   # запасной — всегда ошибка компиляции
```

### Правила и ограничения

- **Только внутри async-процедуры.** Использование `await` на верхнем уровне или в обычной процедуре даёт: *"Can only 'await' inside a proc marked as 'async'. Use 'waitFor' instead."*
- Аргумент должен быть `Future[T]`. Передача чего-либо другого попадает в запасной шаблон и завершается ошибкой при компиляции.
- Ожидание `nil`-Future вызывает `AssertionDefect` во время выполнения (перехватывается механизмом `createCb`).

### Примеры

#### Ожидание значения

```nim
proc download(url: string): Future[string] {.async.} =
  # getContent возвращает Future[string]
  let body = await getContent(url)
  return body.toUpperAscii()
```

`await getContent(url)` приостанавливает `download` без блокировки потока ОС. Цикл событий выполняет другие задачи, пока `getContent` не завершится, затем возобновляет `download` с результатом.

#### Цепочка await

```nim
proc pipeline(): Future[void] {.async.} =
  let raw  = await fetchRaw()       # ждём сырые данные
  let data = await parseAsync(raw)  # ждём разбор
  await saveAsync(data)             # ждём сохранение
```

Каждый `await` — точка приостановки. Процедура читается как последовательный код, но выполняется асинхронно.

#### Параллельное ожидание через `asyncdispatch.all`

```nim
proc fetchBoth(): Future[void] {.async.} =
  # Запускаем оба, ждём объединённый future
  let (a, b) = await all(fetchA(), fetchB())
  echo a, " ", b
```

#### Примеры ошибок компиляции

```nim
# Неверно: вне async
let x = await someAsyncProc()  # ОШИБКА: используйте waitFor

# Неверно: не Future
proc doStuff() {.async.} =
  let x = await 42  # ОШИБКА: await expects Future[T], got int
```

---

## `multisync`

### Что делает

`multisync` решает распространённую задачу разработки библиотек на Nim: вы хотите предоставить и **блокирующую (синхронную)**, и **неблокирующую (асинхронную)** версию одной процедуры, не поддерживая два экземпляра логики.

Макрос принимает **одну процедуру**, типы параметров которой записаны как **объединение типов** через `|` (или `or`), причём одна из ветвей содержит слово `async` (например, `Socket | AsyncSocket`). Из этого единственного определения генерируются **две процедуры**:

- **Асинхронная версия** применяет макрос `async` и использует типы из ветви `AsyncSocket`.
- **Синхронная версия** сворачивает `Future[T]` в обычный `T`, заменяет `await expr` просто на `expr` и использует типы из ветви `Socket`.

Таким образом, тело пишется один раз, а вызовы `await` просто исчезают в синхронном варианте.

### Сигнатура

```nim
macro multisync*(prc: untyped): untyped
```

### Правила и ограничения

- Типы параметров должны использовать `|`/`or` для разделения синхронной и асинхронной ветвей. В имени типа асинхронной ветви должно присутствовать слово `async` (применяется нормализация регистра).
- Тип возврата должен быть `Future[T]`; в синхронной версии он станет просто `T`.
- `await` в теле превращается в no-op в синхронной версии — значение проходит насквозь без изменений.

### Примеры

#### Классическое чтение из сокета

```nim
import asyncdispatch, asyncnet, net

proc readLine(socket: Socket | AsyncSocket): Future[string] {.multisync.} =
  # В синхронной версии:  socket.readLine()
  # В асинхронной версии: await socket.readLine()
  result = await socket.readLine()
```

После раскрытия макроса компилятор видит примерно следующее:

```nim
# Синхронная версия (сгенерированная)
proc readLine(socket: Socket): string =
  result = socket.readLine()   # await убран

# Асинхронная версия (сгенерированная)
proc readLine(socket: AsyncSocket): Future[string] {.async.} =
  result = await socket.readLine()
```

Вызывающий код синхронной версии никогда не сталкивается с `Future`; код, использующий асинхронную версию, работает с `await` как обычно.

#### Несколько параметров со смешанными типами

```nim
proc transfer(src: Socket | AsyncSocket,
              dst: Socket | AsyncSocket,
              n: int): Future[void] {.multisync.} =
  let data = await src.recv(n)
  await dst.send(data)
```

Оба параметра — `src` и `dst` — получают раздельные типы независимо для каждой сгенерированной версии.

#### Зачем не писать просто две процедуры?

```nim
# Без multisync — два экземпляра для поддержки:
proc doWork(s: Socket): string =
  let line = s.readLine()
  process(line)

proc doWork(s: AsyncSocket): Future[string] {.async.} =
  let line = await s.readLine()
  process(line)  # баг: забыли обновить async-копию!

# С multisync — один источник истины:
proc doWork(s: Socket | AsyncSocket): Future[string] {.multisync.} =
  let line = await s.readLine()
  process(line)
```

---

## Внутренние символы (не экспортируются, для справки)

Они не являются частью публичного API, но понимание их роли помогает расшифровывать сообщения об ошибках и трассировки стека.

| Символ | Роль |
|--------|------|
| `asyncSingleProc` | Ядро трансформации: переписывает одну процедуру в итератор + callback |
| `createCb` (template) | Генерирует callback повторного входа, управляющий итератором |
| `processBody` | Рекурсивный обход AST, переписывающий `return` и отслеживающий `try`/`finally` |
| `getFutureVarIdents` | Собирает параметры типа `FutureVar[T]` для автозавершения при выходе |
| `splitProc` | Делит `multisync`-процедуру на синхронную и асинхронную половины |
| `NimAsyncContinueSuffix` | Суффикс к именам callback-ов; распознаётся `asyncfutures` для красивых трассировок |

---

## Частые ошибки и их смысл

| Сообщение об ошибке | Причина | Исправление |
|---|---|---|
| `Expected return type of 'Future' got 'X'` | async-процедура возвращает не-Future тип | Изменить тип возврата на `Future[X]` |
| `Cannot make async proc discardable` | `{.discardable.}` на async-процедуре | Использовать `asyncCheck` для отбрасывания future |
| `await expects Future[T], got X` | Не-Future передан в `await` | Передать значение типа `Future[T]` |
| `Can only 'await' inside a proc marked as 'async'` | `await` вне async-контекста | Пометить процедуру `{.async.}` или использовать `waitFor` |
| `Async procedure (X) yielded nil` | `await` получил `nil`-Future | Убедиться, что вызываемая async-процедура не возвращает `nil` |

---

## Краткая памятка

```nim
# Отметить процедуру как async — Future возвращается автоматически
proc myProc(): Future[int] {.async.} = ...

# Приостановить и распаковать внутри async
let val = await someAsyncProc()

# Сгенерировать синхронный и асинхронный близнецы из одного тела
proc myProc(s: Socket | AsyncSocket): Future[string] {.multisync.} =
  result = await s.readLine()
```
