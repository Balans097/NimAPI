# std/unittest — справочник по модулю

> Встроенный фреймворк Nim для написания и запуска юнит-тестов.
> Тесты объявляются простыми шаблонами, результат выводится после каждого теста,
> а процесс завершается с кодом `1`, если хотя бы один тест провалился.

---

## Содержание

1. [Ключевые концепции](#ключевые-концепции)
2. [Запуск тестов из командной строки](#запуск-тестов-из-командной-строки)
3. [Типы](#типы)
4. [Глобальные переменные](#глобальные-переменные)
5. [Структура тестов](#структура-тестов)
   - [`suite`](#suite)
   - [`test`](#test)
   - [`setup` и `teardown`](#setup-и-teardown)
6. [Утверждения и проверки](#утверждения-и-проверки)
   - [`check`](#check)
   - [`require`](#require)
   - [`expect`](#expect)
   - [`fail`](#fail)
   - [`skip`](#skip)
   - [`checkpoint`](#checkpoint)
7. [Форматтеры вывода](#форматтеры-вывода)
   - [OutputFormatter (базовый)](#outputformatter-базовый)
   - [ConsoleOutputFormatter](#consoleoutputformatter)
   - [JUnitOutputFormatter](#junitoutputformatter)
8. [Настройка на этапе компиляции и через окружение](#настройка-на-этапе-компиляции-и-через-окружение)
9. [Ограничения](#ограничения)
10. [Сводная шпаргалка](#сводная-шпаргалка)

---

## Ключевые концепции

`std/unittest` строится на трёх идеях:

**Тесты — это именованные блоки кода.** Блок `test "имя": тело` выполняет своё тело, перехватывает необработанные исключения и записывает, прошёл тест, провалился или был пропущен.

**Наборы (suite) группируют связанные тесты.** Блок `suite "имя": тело` объединяет несколько тестов, предоставляет общие хуки `setup`/`teardown`, выполняющиеся вокруг каждого теста, и добавляет имя набора в вывод.

**Утверждения по умолчанию нефатальны.** Провалившийся `check` печатает диагностику и помечает тест как неудавшийся, но выполнение текущего теста продолжается — это позволяет увидеть все сбои за один прогон. Используйте `require`, если нужна жёсткая остановка.

---

## Запуск тестов из командной строки

После компиляции (или с `nim c -r`) можно передавать имена или паттерны тестов как аргументы командной строки, чтобы запустить только их подмножество.

### Запустить все тесты (по умолчанию)

```sh
nim c -r mytest.nim
```

### Запустить конкретные тесты по точному имени

```sh
nim c -r mytest.nim "имя моего теста" "другой тест"
```

### Запустить весь набор (suite)

Добавьте `::` в конец имени набора:

```sh
nim c -r mytest.nim "имя набора::"
```

### Фильтрация с glob-паттернами

Одна `*` работает как подстановочный символ, соответствующий любой последовательности символов. `::` разделяет паттерн набора и паттерн теста. Запускаются тесты, подходящие **хотя бы под один** из аргументов.

```sh
nim c -r mytest.nim "fast_suite::mytest1" "fast_suite::mytest2"
nim c -r mytest.nim "fast_suite::mytest*"
nim c -r mytest.nim "auth*::" "crypto::hashing*"

# Запустить наборы, начинающиеся с 'bug #', и автономные тесты, начинающиеся с '#'
nim c -r mytest.nim 'bug #*::' '::#*'
```

Если аргументы не переданы, запускаются все тесты.

---

## Типы

### `TestStatus`

```nim
type TestStatus* = enum
  OK,
  FAILED,
  SKIPPED
```

Результат отдельного теста после его завершения. `OK` — ни одно утверждение не провалилось и исключений не было. `FAILED` — хотя бы один `check`/`require` провалился, или необработанное исключение вышло из тела теста. `SKIPPED` — внутри теста был вызван `skip()`.

---

### `OutputLevel`

```nim
type OutputLevel* = enum
  PRINT_ALL,       ## Печатать все результаты
  PRINT_FAILURES,  ## Печатать только провалившиеся тесты
  PRINT_NONE       ## Не печатать ничего
```

Управляет подробностью консольного форматтера. По умолчанию `PRINT_ALL`. Можно задать на этапе компиляции флагом `-d:nimUnittestOutputLevel:PRINT_FAILURES` или через устаревшую переменную окружения `NIMTEST_OUTPUT_LVL`.

---

### `TestResult`

```nim
type TestResult* = object
  suiteName*: string   ## Имя набора, или "" если тест не в наборе
  testName*:  string   ## Имя теста
  status*:    TestStatus
```

Снимок результата теста, передаваемый форматтерам в момент завершения теста. Форматтеры получают этот объект и используют его для записи вывода в нужном формате.

---

### `OutputFormatter`

```nim
type OutputFormatter* = ref object of RootObj
```

Абстрактный базовый класс для всех форматтеров вывода. Пользовательские форматтеры наследуются от этого типа и переопределяют его методы. В модуле есть две готовые реализации: `ConsoleOutputFormatter` и `JUnitOutputFormatter`.

---

### `ConsoleOutputFormatter`

```nim
type ConsoleOutputFormatter* = ref object of OutputFormatter
```

Форматтер по умолчанию. Выводит результаты тестов в терминал в человекочитаемом виде, при желании — с цветами. Цветной вывод автоматически определяется через `isatty(stdout)` и может быть переопределён компиляционным флагом `-d:nimUnittestColor:on|off|auto`.

---

### `JUnitOutputFormatter`

```nim
type JUnitOutputFormatter* = ref object of OutputFormatter
```

Форматтер, записывающий результаты в JUnit-совместимый XML в любой `Stream`. Полезен для интеграции с CI-инструментами (Jenkins, GitLab CI, GitHub Actions и др.), понимающими JUnit XML.

---

## Глобальные переменные

### `abortOnError`

```nim
var abortOnError* {.threadvar.}: bool
```

Если установлено в `true`, любой провал теста немедленно вызывает `quit(1)` вместо продолжения. Блоки `teardown` в этом случае **не выполняются**. По умолчанию `false` — провалившиеся тесты записываются, и выполнение продолжается. Можно включить на этапе компиляции флагом `-d:nimUnittestAbortOnError:on`.

```nim
abortOnError = true   # установка в рантайме
```

---

## Структура тестов

### `suite`

```nim
template suite*(name, body) {.dirty.}
```

Объявляет именованную группу связанных тестов. `body` может содержать блоки `setup`, `teardown` и `test`, а также любой обычный Nim-код (который выполняется один раз при входе в блок `suite`, до всех тестов).

Наборы добавляют в вывод заголовок вида `[Suite] имя набора` и делают отступы у результатов тестов. Вложение наборов допустимо, но провал теста во вложенном наборе не помечает родительский как провалившийся.

```nim
suite "арифметика":
  echo "выполняется один раз, до всех тестов набора"

  setup:
    let x = 10   # выполняется перед каждым тестом

  teardown:
    echo "очистка"   # выполняется после каждого теста

  test "сложение":
    check x + 5 == 15

  test "вычитание":
    check x - 3 == 7

  echo "выполняется один раз, после всех тестов"
```

Вывод:

```
[Suite] арифметика
  [OK] сложение
  [OK] вычитание
```

---

### `test`

```nim
template test*(name, body) {.dirty.}
```

Объявляет единственный тест-кейс с человекочитаемым именем. Тело выполняется при запуске теста. Любое необработанное исключение, возникшее в теле, автоматически помечает тест как провалившийся и печатает сообщение об ошибке и стектрейс.

Тесты можно определять на верхнем уровне (вне `suite`) или внутри блока `suite`.

```nim
test "базовая истина":
  check 1 + 1 == 2

test "операции со строками":
  let s = "hello"
  check s.len == 5
  check s.toUpperAscii() == "HELLO"
```

Тест считается успешным, если его тело дошло до конца без провала ни одного `check` и без необработанных исключений.

---

### `setup` и `teardown`

`setup` и `teardown` — под-шаблоны, которые можно использовать **внутри блока `suite`**. Они определяют код, выполняющийся **до** и **после каждого отдельного теста** в наборе соответственно.

```nim
suite "тесты базы данных":
  var db: DatabaseConnection

  setup:
    db = openTestDatabase()       # выполняется перед каждым тестом
    db.beginTransaction()

  teardown:
    db.rollback()                 # выполняется после каждого теста
    db.close()

  test "вставка записи":
    db.insert(Record(id: 1))
    check db.count() == 1

  test "удаление записи":
    db.insert(Record(id: 2))
    db.delete(2)
    check db.count() == 0
```

`setup` выполняется первым в каждом тесте, до тела теста. `teardown` всегда выполняется после тела теста, даже если тест провалился (регистрируется через `defer`). Набор может иметь не более одного блока `setup` и одного `teardown`. Вложенные наборы наследуют `setup`/`teardown` родителя, но могут переопределить их локально.

---

## Утверждения и проверки

### `check`

```nim
macro check*(conditions: untyped): untyped
```

Основной макрос утверждений. Вычисляет булево условие (или блок условий) и, если оно ложно, печатает диагностическое сообщение с местом сбоя и значениями подвыражений, затем помечает тест как провалившийся. Выполнение текущего теста **продолжается** после провала `check`.

**Одиночное условие:**

```nim
check 2 + 2 == 4
check myList.len > 0
check "hello".startsWith("he")
```

**Блок условий (каждое проверяется независимо):**

```nim
check:
  result != nil
  result.name == "Алиса"
  result.age >= 18
```

**Что делает `check` особенным:** при провале сравнения вроде `a == b` макрос выводит не просто «check failed», а реальные значения обоих операндов в рантайме. Если `x = 5` и написано `check x == 10`, вывод будет содержать что-то вроде `x was 5`. Это достигается переписыванием выражения на этапе компиляции с помощью макросов.

**Важное ограничение:** поскольку `check` внутренне присваивает подвыражения временным переменным, смешанные сравнения типов вроде `check 4.0 == 2 + 2` могут не скомпилироваться. Используйте `doAssert` в таких случаях, или убедитесь что оба операнда имеют один и тот же тип.

---

### `require`

```nim
template require*(conditions: untyped)
```

Полностью идентичен `check`, за одним исключением: провал немедленно завершает всю программу (вызывает `quit(1)`) независимо от значения `abortOnError`. Блоки `teardown` после провала `require` **не выполняются**.

Используйте `require` для предварительных условий, при нарушении которых весь последующий код теста лишён смысла — например, чтобы проверить существование файла перед его чтением.

```nim
test "разбор конфигурационного файла":
  require fileExists("config.json")   # при провале — весь прогон останавливается
  let cfg = parseFile("config.json")
  check cfg["key"].getStr == "value"
```

---

### `expect`

```nim
macro expect*(exceptions: varargs[typed], body: untyped): untyped
```

Проверяет, что выполнение `body` вызывает одно из указанных исключений. Тест проходит, если тело выбрасывает исключение подходящего типа. Тест проваливается, если тело завершилось без исключения, или выбросило исключение другого типа.

```nim
test "выход за границы вызывает ошибку":
  let v = @[1, 2, 3]
  expect IndexDefect:
    discard v[10]

test "несколько допустимых исключений":
  expect IOError, OSError:
    discard readFile("/несуществующий/путь")

test "разбор неверных данных":
  expect ValueError:
    discard parseInt("не число")
```

Если в списке исключений указан `Exception`, `expect` использует упрощённую форму, принимающую любое исключение без проверки конкретного типа.

---

### `fail`

```nim
template fail*
```

Вручную помечает текущий тест как провалившийся. Печатает накопленные контрольные точки (checkpoints), затем либо завершает программу (если `abortOnError = true`), либо продолжает. После `fail` список контрольных точек очищается.

`fail` редко нужен напрямую в прикладном коде тестов — это внутренний примитив, который вызывают `check` и `require`. Он полезен при написании вспомогательных утверждений или для сигнализации о провале на основе сложной логики, которую нельзя выразить простым булевым выражением:

```nim
test "пользовательский провал":
  checkpoint("Сейчас проверим что-то сложное")
  if not complexCondition():
    checkpoint("complexCondition вернула false")
    fail
```

---

### `skip`

```nim
template skip*
```

Помечает текущий тест как `SKIPPED` вместо `OK` или `FAILED`. Тело теста **продолжает выполняться** после вызова `skip` (в отличие от `return`). Используйте, когда тест не имеет смысла в текущем окружении — например, когда нужный внешний ресурс недоступен.

```nim
test "GPU-рендеринг":
  if not isGPUAvailable():
    skip()
  # код ниже всё равно выполняется, но тест записан как SKIPPED
  let result = renderFrame()
  check result.width == 1920
```

Поскольку выполнение продолжается, часто имеет смысл обернуть оставшийся код теста в `if`-блок, проверяющий условие пропуска.

---

### `checkpoint`

```nim
proc checkpoint*(msg: string)
```

Записывает диагностическое сообщение, которое будет напечатано, если текущий тест впоследствии провалится. Контрольные точки накапливаются в списке; когда срабатывает `fail` (из-за провала `check`, необработанного исключения или прямого вызова), все накопленные с момента последней очистки точки печатаются перед сообщением об ошибке.

Контрольные точки дают контекст для провала — работают как «хлебные крошки», позволяя проследить, что происходило до момента сбоя.

```nim
test "сложный многошаговый процесс":
  checkpoint("Шаг 1: инициализация")
  let ctx = initialize()

  checkpoint("Шаг 2: обработка, ctx=" & $ctx.id)
  let result = process(ctx)

  checkpoint("Шаг 3: проверка результата")
  check result.valid        # при провале будут напечатаны все три точки
  check result.value == 42
```

Контрольные точки автоматически очищаются после завершения каждого теста (независимо от его результата).

---

## Форматтеры вывода

Форматтеры — это бэкенд вывода тест-раннера. Несколько форматтеров могут быть активны одновременно — например, вывод в консоль и запись JUnit XML одновременно.

### `addOutputFormatter`

```nim
proc addOutputFormatter*(formatter: OutputFormatter)
```

Добавляет форматтер в список активных. Все последующие события жизненного цикла тестов (начало набора, начало теста, провал, конец теста, конец набора) будут отправлены в этот форматтер.

```nim
let f = newJUnitOutputFormatter(openFileStream("results.xml", fmWrite))
addOutputFormatter(f)
# запускаем тесты...
f.close()
```

---

### `delOutputFormatter`

```nim
proc delOutputFormatter*(formatter: OutputFormatter)
```

Удаляет конкретный форматтер из активного списка. Полезно, когда форматтер нужен только для части тестового прогона.

---

### `resetOutputFormatters`

```nim
proc resetOutputFormatters*
```

Полностью очищает список форматтеров. После вызова никакой вывод не производится до добавления нового форматтера. Используется при тестировании самого тестового фреймворка или при полной смене форматтеров в процессе прогона.

---

### `newConsoleOutputFormatter`

```nim
proc newConsoleOutputFormatter*(
  outputLevel: OutputLevel = PRINT_ALL,
  colorOutput = true
): ConsoleOutputFormatter
```

Создаёт новый консольный форматтер с указанным уровнем подробности и настройкой цвета. Обычно вызывать напрямую не нужно — модуль автоматически создаёт форматтер по умолчанию при первом использовании. Вызывайте явно, если нужен форматтер с нестандартными настройками.

```nim
let fmt = newConsoleOutputFormatter(PRINT_FAILURES, colorOutput = false)
addOutputFormatter(fmt)
```

---

### `defaultConsoleFormatter`

```nim
proc defaultConsoleFormatter*(): ConsoleOutputFormatter
```

Создаёт консольный форматтер, который модуль использовал бы по умолчанию, — с учётом компиляционных флагов для уровня вывода и цвета, а также устаревших переменных окружения. Модуль вызывает это внутренне при первом использовании; явный вызов нужен только при сбросе к форматтеру по умолчанию после его замены.

---

### OutputFormatter — виртуальные методы

Эти методы составляют протокол жизненного цикла, который должны реализовывать все форматтеры. Тест-раннер вызывает их в нужные моменты. Переопределяйте их в пользовательском форматтере:

```nim
method suiteStarted*(formatter: OutputFormatter, suiteName: string) {.base.}
method testStarted*(formatter: OutputFormatter, testName: string) {.base.}
method failureOccurred*(formatter: OutputFormatter, checkpoints: seq[string], stackTrace: string) {.base.}
method testEnded*(formatter: OutputFormatter, testResult: TestResult) {.base.}
method suiteEnded*(formatter: OutputFormatter) {.base.}
```

| Метод | Когда вызывается |
|---|---|
| `suiteStarted` | При начале блока `suite` |
| `testStarted` | При начале блока `test` |
| `failureOccurred` | При вызове `fail` (после провала `check` или перехвата исключения) |
| `testEnded` | При завершении блока `test` (всегда, даже при провале) |
| `suiteEnded` | При завершении блока `suite` |

`failureOccurred` получает накопленные контрольные точки и, если провал вызван исключением, стектрейс этого исключения. Базовые реализации ничего не делают — каждый конкретный форматтер переопределяет нужные ему методы.

**Пример — пользовательский форматтер:**

```nim
type MyFormatter = ref object of OutputFormatter
  passed, failed: int

method testEnded*(f: MyFormatter, r: TestResult) =
  if r.status == OK: inc f.passed
  else: inc f.failed

let f = MyFormatter()
addOutputFormatter(f)
# ... запускаем тесты ...
echo f.passed, " прошло, ", f.failed, " провалилось"
```

---

### `newJUnitOutputFormatter`

```nim
proc newJUnitOutputFormatter*(stream: Stream): JUnitOutputFormatter
```

Создаёт форматтер, пишущий JUnit-совместимый XML в `stream`. Поток **не** закрывается автоматически — необходимо вызвать `formatter.close()` после завершения всех тестов, чтобы дозаписать закрывающие XML-теги и закрыть поток.

```nim
import std/[unittest, streams]

let xmlOut = newFileStream("results.xml", fmWrite)
let jfmt = newJUnitOutputFormatter(xmlOut)
addOutputFormatter(jfmt)

suite "мой набор":
  test "проходит": check 1 == 1
  test "не проходит": check 1 == 2

jfmt.close()   # записывает </testsuites> и закрывает файл
```

---

### `close` (JUnitOutputFormatter)

```nim
proc close*(formatter: JUnitOutputFormatter)
```

Завершает JUnit XML-отчёт: записывает закрывающий тег `</testsuites>` и закрывает поток. Должен быть вызван после последнего теста.

---

## `disableParamFiltering`

```nim
proc disableParamFiltering*
```

По умолчанию фреймворк при запуске читает аргументы командной строки и использует их как фильтры имён тестов. Вызов `disableParamFiltering()` до первого теста отключает это поведение, и все тесты выполняются независимо от аргументов командной строки. Полезно при встраивании тест-раннера в более крупное приложение с собственной обработкой аргументов.

```nim
disableParamFiltering()
# теперь все тесты запускаются даже при наличии аргументов CLI
```

---

## Настройка на этапе компиляции и через окружение

| Механизм | Эффект |
|---|---|
| `-d:nimUnittestOutputLevel:PRINT_ALL\|PRINT_FAILURES\|PRINT_NONE` | Уровень подробности вывода |
| `-d:nimUnittestColor:auto\|on\|off` | Цветной вывод в консоли |
| `-d:nimUnittestAbortOnError:on\|off` | Значение `abortOnError` по умолчанию |
| `abortOnError = true` (рантайм) | То же, но в рантайме |
| `addOutputFormatter(jfmt)` | Добавить JUnit или пользовательский форматтер |

Устаревшие (ещё поддерживаются, но могут быть удалены в будущем):

| Переменная окружения | Эффект |
|---|---|
| `NIMTEST_OUTPUT_LVL` | `PRINT_ALL`, `PRINT_FAILURES` или `PRINT_NONE` |
| `NIMTEST_COLOR` | `always` или `never` |
| `NIMTEST_NO_COLOR` | Если задана, отключает цвет |
| `NIMTEST_ABORT_ON_ERROR` | Если задана, включает аварийную остановку |

---

## Ограничения

### Смешанные типы в `check`

Поскольку `check` переписывает сравнения для захвата значений подвыражений, он присваивает каждый операнд временной переменной. Это ломается, когда операнды имеют разные типы без неявного преобразования:

```nim
check 4.0 == 2 + 2   # может не скомпилироваться — несоответствие типов
doAssert 4.0 == 2 + 2  # работает нормально
```

**Обходной путь:** убедитесь, что оба операнда любого оператора в выражении `check` имеют одинаковый тип, или используйте `doAssert` для сравнений разных типов.

### Параметры шаблонов не интерполируются в `check`

По той же причине `check` не может видеть параметры шаблонов по имени — строка внутри форматного макроса не находится в развёрнутом контексте шаблона. Привяжите параметр шаблона к локальной переменной первым делом:

```nim
template myAssert(val: int): untyped =
  let v = val
  check v > 0   # используйте v, не val
```

### `skip` не останавливает выполнение тела теста

Вызов `skip()` устанавливает статус теста в `SKIPPED`, но не выходит из тела теста. Если нужно пропустить все оставшиеся утверждения, поместите их в `if`-блок, проверяющий условие пропуска, или реструктурируйте тест.

### `teardown` не выполняется после провала `require`

Если `require` проваливается, программа немедленно завершается. Блоки `teardown` не выполняются. Используйте `check` вместо `require`, если очистка в `teardown` важна для корректности.

---

## Сводная шпаргалка

### Структура тестов

```nim
suite "имя набора":
  setup:
    # выполняется перед каждым тестом в наборе

  teardown:
    # выполняется после каждого теста в наборе

  test "имя теста":
    # тело теста

test "автономный тест":
  # вне любого набора
```

### Утверждения

| Шаблон / Макрос | Поведение при провале |
|---|---|
| `check expr` | Печатает диагностику, помечает тест FAILED, продолжает |
| `check: expr1; expr2` | Проверяет каждое независимо |
| `require expr` | Немедленно завершает программу |
| `expect ExcType: body` | Провал, если тело не выбрасывает ExcType |
| `fail` | Вручную пометить тест как FAILED |
| `skip` | Пометить тест как SKIPPED (тело продолжается) |
| `checkpoint("сообщение")` | Записать «хлебную крошку» (печатается при провале) |

### Форматтеры

| Процедура | Назначение |
|---|---|
| `addOutputFormatter(f)` | Добавить форматтер |
| `delOutputFormatter(f)` | Удалить форматтер |
| `resetOutputFormatters()` | Очистить все форматтеры |
| `newConsoleOutputFormatter(level, color)` | Создать консольный форматтер |
| `defaultConsoleFormatter()` | Создать форматтер по умолчанию |
| `newJUnitOutputFormatter(stream)` | Создать JUnit XML форматтер |
| `jfmt.close()` | Завершить JUnit XML отчёт |

### Настройка

| Опция | Назначение |
|---|---|
| `abortOnError = true` | Остановиться при первом провале |
| `disableParamFiltering()` | Игнорировать CLI-фильтры тестов |
| `-d:nimUnittestOutputLevel:PRINT_FAILURES` | Показывать только провалы |
| `-d:nimUnittestColor:off` | Отключить цветной вывод |
