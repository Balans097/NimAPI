# algorithm.nim — Справочник модуля

> **Импорт:** `import std/algorithm`  
> **Область применения:** Универсальные алгоритмы для `openArray[T]` — работают с массивами, последовательностями и любым смежным контейнером.

Модуль реализует стандартный набор алгоритмов для работы с массивами: сортировка, бинарный поиск, заполнение, разворот, вращение, перестановки и декартово произведение. Почти каждая процедура существует в двух вариантах: **изменяющем** исходный контейнер «на месте» и **неизменяющем**, возвращающем новую последовательность. Неизменяющие варианты легко узнать по суффиксу `-ed` в названии: `reversed`, `rotatedLeft`, `sorted`.

---

## Типы и вспомогательные средства

### `SortOrder`

```nim
type SortOrder* = enum
  Descending, Ascending
```

Перечисление, которое задаёт направление упорядочивания во всех процедурах модуля. `Ascending` (по возрастанию) используется по умолчанию почти везде; `Descending` переворачивает порядок.

---

### `*` (множитель порядка)

```nim
proc `*`*(x: int, order: SortOrder): int
```

**Что делает.** Небольшой арифметический помощник: меняет знак результата компаратора на противоположный, если `order == Descending`, и оставляет его без изменений при `Ascending`. Это позволяет алгоритмам сортировки использовать одну и ту же функцию сравнения для обоих направлений без дополнительных ветвлений.

Вызывать напрямую вам придётся редко, но он пригодится при написании собственных алгоритмов, которые опираются на `SortOrder`.

```nim
# Компаратор вернул +5 (левый > правого)
assert 5  * Ascending  ==  5   # порядок не меняется
assert 5  * Descending == -5   # знак перевёрнут → левый стал «меньше»
assert -3 * Descending ==  3
```

---

## Заполнение

### `fill` (срез)

```nim
proc fill*[T](a: var openArray[T], first, last: Natural, value: T)
```

**Что делает.** Записывает `value` во все элементы контейнера `a` в диапазоне индексов `first..last` включительно. Элементы за пределами диапазона не затрагиваются. При выходе за границы поднимается `IndexDefect`.

Можно представить это как «заливку краской» заданного участка массива.

```nim
var a = [0, 0, 0, 0, 0, 0]
a.fill(1, 4, 7)
assert a == [0, 7, 7, 7, 7, 0]
```

---

### `fill` (весь контейнер)

```nim
proc fill*[T](a: var openArray[T], value: T)
```

**Что делает.** Упрощённый вариант: заполняет **весь** контейнер значением `value`. Эквивалентен вызову `fill` с `first = 0` и `last = a.high`.

```nim
var a = [1, 2, 3, 4, 5]
a.fill(0)
assert a == [0, 0, 0, 0, 0]
```

---

## Разворот

### `reverse` (срез)

```nim
proc reverse*[T](a: var openArray[T], first, last: Natural)
```

**Что делает.** Разворачивает элементы `a` **на месте** в пределах подмассива `first..last`. Элементы вне диапазона остаются нетронутыми. Двойной вызов с одинаковым диапазоном восстанавливает исходный порядок. Поднимает `IndexDefect` при некорректном диапазоне.

```nim
var a = [1, 2, 3, 4, 5, 6]
a.reverse(1, 4)
assert a == [1, 5, 4, 3, 2, 6]  # перевёрнуты только индексы 1..4
```

---

### `reverse` (весь контейнер)

```nim
proc reverse*[T](a: var openArray[T])
```

**Что делает.** Разворачивает весь контейнер на месте. Пустой контейнер обрабатывается безопасно.

```nim
var a = [1, 2, 3, 4, 5]
a.reverse()
assert a == [5, 4, 3, 2, 1]
```

---

### `reversed`

```nim
proc reversed*[T](a: openArray[T]): seq[T]
```

**Что делает.** Неизменяющий аналог `reverse`. Возвращает новый `seq[T]` с элементами в обратном порядке; исходный контейнер не затрагивается. Безопасен для пустого ввода.

```nim
let original = [10, 20, 30]
let rev = original.reversed()
assert rev      == @[30, 20, 10]
assert original == [10, 20, 30]   # не изменён
```

---

## Поиск

### `binarySearch` (с пользовательским компаратором)

```nim
proc binarySearch*[T, K](a: openArray[T], key: K,
                         cmp: proc (x: T, y: K): int): int
```

**Что делает.** Выполняет бинарный поиск ключа `key` в отсортированном массиве `a`. Возвращает **индекс** найденного элемента или `-1`, если элемент не найден. Массив обязан быть отсортирован в том же порядке, что задаёт `cmp`.

Параметры типа `T` и `K` независимы: можно искать в `seq[Person]` по обычной строке-имени. Компаратор следует стандартному соглашению: отрицательный результат — «левый < правого», ноль — равны, положительный — «левый > правого».

Бинарный поиск работает за O(log n) — кратно быстрее линейного перебора на больших отсортированных данных.

```nim
let words = ["apple", "banana", "cherry", "date"]
assert binarySearch(words, "cherry", system.cmp[string]) == 2
assert binarySearch(words, "grape",  system.cmp[string]) == -1
```

---

### `binarySearch` (компаратор по умолчанию)

```nim
proc binarySearch*[T](a: openArray[T], key: T): int
```

**Что делает.** Упрощённый вариант, использующий `system.cmp[T]` — не нужно передавать компаратор для стандартных сравниваемых типов.

```nim
assert binarySearch([0, 1, 2, 3, 4], 3) == 3
assert binarySearch([0, 1, 2, 3, 4], 9) == -1
```

---

### `lowerBound` (с компаратором)

```nim
proc lowerBound*[T, K](a: openArray[T], key: K,
                       cmp: proc(x: T, k: K): int): int
```

**Что делает.** В отсортированной последовательности возвращает индекс **первого элемента, который ≥ key** («левая граница вставки»). Если все элементы меньше `key`, возвращает `a.len` — позицию за последним элементом. Вставка по этому индексу сохраняет сортировку.

Ключевое отличие от `binarySearch`: `lowerBound` всегда возвращает корректную позицию для вставки, даже если элемент отсутствует.

```nim
let a = @[1, 2, 3, 5, 6, 7]
# 4 отсутствует — lowerBound указывает, куда его вставить
assert a.lowerBound(4, system.cmp[int]) == 3   # между 3 и 5
assert a.lowerBound(3, system.cmp[int]) == 2   # указывает на существующий 3
```

---

### `lowerBound` (компаратор по умолчанию)

```nim
proc lowerBound*[T](a: openArray[T], key: T): int
```

**Что делает.** То же самое, с `system.cmp[T]`.

```nim
var s = @[10, 20, 30, 40]
s.insert(25, s.lowerBound(25))   # вставляем на правильную позицию
assert s == @[10, 20, 25, 30, 40]
```

---

### `upperBound` (с компаратором)

```nim
proc upperBound*[T, K](a: openArray[T], key: K,
                       cmp: proc(x: T, k: K): int): int
```

**Что делает.** Возвращает индекс **первого элемента, строго большего `key`** («правая граница вставки»). Вставка по этому индексу сохраняет сортировку и помещает новый элемент после всех уже существующих равных. Поднимает `IndexDefect` при некорректном диапазоне.

Разница между `lowerBound` и `upperBound` проявляется при наличии дубликатов: `lowerBound` указывает перед серией одинаковых элементов, `upperBound` — после неё.

```nim
let a = @[1, 2, 3, 3, 3, 6]
assert a.lowerBound(3, system.cmp[int]) == 2  # перед первым 3
assert a.upperBound(3, system.cmp[int]) == 5  # после последнего 3
```

---

### `upperBound` (компаратор по умолчанию)

```nim
proc upperBound*[T](a: openArray[T], key: T): int
```

**Что делает.** То же самое, с `system.cmp[T]`.

---

## Сортировка

### `sort` (с компаратором)

```nim
func sort*[T](a: var openArray[T],
              cmp: proc (x, y: T): int,
              order = SortOrder.Ascending)
```

**Что делает.** Сортирует `a` **на месте** итеративным алгоритмом слияния (merge sort). Гарантии:
- **Устойчивость** — одинаковые элементы сохраняют взаимный порядок.
- **O(n log n) в худшем случае** — нет деградации на «злых» данных.
- Использует временный буфер размером `n / 2`.

Критерий сортировки задаётся функцией `cmp`. Синтаксис `do` позволяет записывать компаратор прямо в вызове без лишних объявлений. `Descending` разворачивает порядок.

```nim
var people = [("Алиса", 30), ("Боб", 25), ("Карина", 30)]

# Сначала по возрасту, при совпадении — по имени
people.sort do (x, y: (string, int)) -> int:
    result = cmp(x[1], y[1])
    if result == 0: result = cmp(x[0], y[0])

assert people == [("Боб", 25), ("Алиса", 30), ("Карина", 30)]
```

---

### `sort` (компаратор по умолчанию)

```nim
proc sort*[T](a: var openArray[T], order = SortOrder.Ascending)
```

**Что делает.** Краткий вариант с `system.cmp[T]` — достаточно для чисел, строк и любых типов со стандартным сравнением.

```nim
var nums = [5, 3, 1, 4, 2]
nums.sort()
assert nums == [1, 2, 3, 4, 5]

nums.sort(Descending)
assert nums == [5, 4, 3, 2, 1]
```

---

### `sorted` (с компаратором)

```nim
proc sorted*[T](a: openArray[T], cmp: proc(x, y: T): int,
                order = SortOrder.Ascending): seq[T]
```

**Что делает.** Неизменяющий двойник `sort`. Возвращает новую отсортированную `seq[T]`; исходный контейнер остаётся нетронутым. Удобен в функциональных цепочках или когда нужно сохранить оба варианта — оригинальный и отсортированный.

```nim
let original = [3, 1, 4, 1, 5]
let s = original.sorted(system.cmp[int])
assert s        == @[1, 1, 3, 4, 5]
assert original == [3, 1, 4, 1, 5]   // не изменён
```

---

### `sorted` (компаратор по умолчанию)

```nim
proc sorted*[T](a: openArray[T], order = SortOrder.Ascending): seq[T]
```

**Что делает.** Краткий вариант с `system.cmp[T]`.

```nim
assert [4, 2, 7, 1].sorted == @[1, 2, 4, 7]
assert [4, 2, 7, 1].sorted(Descending) == @[7, 4, 2, 1]
```

---

### `sortedByIt`

```nim
template sortedByIt*(seq1, op: untyped): untyped
```

**Что делает.** Шаблон-сокращение вокруг `sorted`. Вводит переменную `it`, в которой последовательно оказывается каждый элемент, и сортирует по вычисленному выражению. Позволяет избежать лишнего кода при сортировке по полю структуры или по кортежу ключей.

```nim
type Person = tuple[name: string, age: int]
let people = @[("Карина", 30), ("Алиса", 25), ("Боб", 30)]

# По возрасту
let byAge = people.sortedByIt(it.age)
assert byAge == @[("Алиса", 25), ("Карина", 30), ("Боб", 30)]

# Сначала по возрасту, затем по имени
let byAgeThenName = people.sortedByIt((it.age, it.name))
assert byAgeThenName == @[("Алиса", 25), ("Боб", 30), ("Карина", 30)]
```

---

### `isSorted` (с компаратором)

```nim
func isSorted*[T](a: openArray[T], cmp: proc(x, y: T): int,
                  order = SortOrder.Ascending): bool
```

**Что делает.** Проверяет за O(n) времени, отсортирован ли `a` в соответствии с `cmp` и `order`. Возвращает `true`, если ни одна пара соседних элементов не нарушает порядок, и `false` при первом же нарушении (с ранним выходом). Полезен как предусловие перед бинарным поиском или постусловие после сортировки.

```nim
assert isSorted([1, 2, 3, 4])             == true
assert isSorted([1, 3, 2, 4])             == false
assert isSorted([4, 3, 2, 1], Descending) == true
```

---

### `isSorted` (компаратор по умолчанию)

```nim
proc isSorted*[T](a: openArray[T], order = SortOrder.Ascending): bool
```

**Что делает.** Краткий вариант с `system.cmp[T]`.

```nim
assert @[1, 1, 2, 3].isSorted == true    # одинаковые элементы допустимы
assert @["а", "в", "б"].isSorted == false
```

---

## Слияние

### `merge` (с компаратором)

```nim
proc merge*[T](result: var seq[T], x, y: openArray[T],
               cmp: proc(x, y: T): int)
```

**Что делает.** Сливает два уже отсортированных массива `x` и `y` в `result`, сохраняя порядок. Слияние устойчиво: при равенстве по `cmp` элемент из `x` идёт первым.

**Важно:** новые элементы **дописываются в конец** `result` — имеющееся содержимое сохраняется. Чтобы получить только слитый результат, предварительно очистите `result` вызовом `result.setLen(0)`.

```nim
let чётные = @[2, 4, 6]
let нечётные = @[1, 3, 5]
var merged: seq[int]
merged.merge(нечётные, чётные, system.cmp[int])
assert merged == @[1, 2, 3, 4, 5, 6]
```

---

### `merge` (компаратор по умолчанию)

```nim
proc merge*[T](result: var seq[T], x, y: openArray[T])
```

**Что делает.** Краткий вариант с `system.cmp[T]`.

```nim
var r: seq[int]
r.merge([1, 3, 5], [2, 4, 6])
assert r == @[1, 2, 3, 4, 5, 6]
```

---

## Комбинаторика

### `product`

```nim
proc product*[T](x: openArray[seq[T]]): seq[seq[T]]
```

**Что делает.** Вычисляет **декартово произведение** набора последовательностей. Каждый элемент результата — одна комбинация, где i-й слот заполнен элементом из `x[i]`. Количество результатов равно произведению длин всех входных последовательностей — оно может расти очень быстро, поэтому применяйте осторожно на больших данных.

```nim
# Все комбинации масти и достоинства карты
let масти  = @["♥", "♠"]
let достоинства = @["A", "K"]
let комбо = product(@[масти, достоинства])
# @[@["♥", "A"], @["♠", "A"], @["♥", "K"], @["♠", "K"]]
assert комбо.len == 4
```

---

### `nextPermutation`

```nim
proc nextPermutation*[T](x: var openArray[T]): bool {.discardable.}
```

**Что делает.** Преобразует `x` на месте в **следующую лексикографическую перестановку**. Возвращает `true`, если перестановка существовала; `false`, если `x` уже была последней (отсортированной по убыванию). При возврате `false` массив остаётся неизменным.

Чтобы перебрать все перестановки, начните с последовательности в порядке возрастания и вызывайте `nextPermutation` в цикле.

```nim
var v = @[1, 2, 3]
var перестановки: seq[seq[int]]
перестановки.add(v)
while v.nextPermutation():
    перестановки.add(v)
assert перестановки.len == 6   # 3! = 6
# @[1,2,3], @[1,3,2], @[2,1,3], @[2,3,1], @[3,1,2], @[3,2,1]
```

---

### `prevPermutation`

```nim
proc prevPermutation*[T](x: var openArray[T]): bool {.discardable.}
```

**Что делает.** Зеркало `nextPermutation` — преобразует `x` в **предыдущую лексикографическую перестановку**. Возвращает `true` при успехе; `false`, если `x` уже была первой (отсортированной по возрастанию). При возврате `false` массив не изменяется.

```nim
var v = @[3, 2, 1]   # последняя перестановка [1,2,3]
assert v.prevPermutation() == true
assert v == @[3, 1, 2]
assert v.prevPermutation() == true
assert v == @[2, 3, 1]
```

---

## Вращение

Вращение циклически сдвигает элементы внутри диапазона. Левое вращение на `dist` позиций перемещает элемент с индекса `i` на индекс `i - dist` (с циклическим переносом). Правое вращение — это левое с отрицательным `dist`.

### `rotateLeft` (срез, на месте)

```nim
proc rotateLeft*[T](arg: var openArray[T]; slice: HSlice[int, int];
                    dist: int): int {.discardable.}
```

**Что делает.** Вращает элементы в пределах `slice` влево на `dist` позиций, изменяя контейнер на месте. Элементы вне среза не затрагиваются. Возвращает индекс того элемента, который находился первым до вращения (используется в ряде алгоритмов). `dist` может быть любым целым числом: отрицательное значение вращает вправо, значение, превышающее длину среза, берётся по модулю.

```nim
var a = [0, 1, 2, 3, 4, 5]
a.rotateLeft(1 .. 4, 2)
assert a == [0, 3, 4, 1, 2, 5]
# индексы 0 и 5 не изменились; внутри 1..4: сдвиг влево на 2
```

---

### `rotateLeft` (весь контейнер, на месте)

```nim
proc rotateLeft*[T](arg: var openArray[T]; dist: int): int {.discardable.}
```

**Что делает.** То же самое, но для всего контейнера целиком.

```nim
var a = [1, 2, 3, 4, 5]
a.rotateLeft(2)
assert a == [3, 4, 5, 1, 2]   # «3 4 5» переехало в начало

a.rotateLeft(-2)
assert a == [1, 2, 3, 4, 5]   # поворот вправо на 2 восстанавливает исходное
```

---

### `rotatedLeft` (срез, неизменяющий)

```nim
proc rotatedLeft*[T](arg: openArray[T]; slice: HSlice[int, int],
                     dist: int): seq[T]
```

**Что делает.** Неизменяющая версия вращения среза. Возвращает новый `seq[T]` с применённым вращением; `arg` остаётся нетронутым.

```nim
let a = @[1, 2, 3, 4, 5]
let b = a.rotatedLeft(1 .. 3, 2)
assert b == @[1, 4, 2, 3, 5]
assert a == @[1, 2, 3, 4, 5]   # исходник не изменён
```

---

### `rotatedLeft` (весь контейнер, неизменяющий)

```nim
proc rotatedLeft*[T](arg: openArray[T]; dist: int): seq[T]
```

**Что делает.** Неизменяющее вращение всего контейнера.

```nim
let a = @[1, 2, 3, 4, 5]
assert a.rotatedLeft(2)  == @[3, 4, 5, 1, 2]
assert a.rotatedLeft(-1) == @[5, 1, 2, 3, 4]
assert a == @[1, 2, 3, 4, 5]   # не изменён
```

---

## Краткая таблица

| Задача | На месте | Новая seq |
|---|---|---|
| Сортировка | `sort` | `sorted`, `sortedByIt` |
| Разворот | `reverse` | `reversed` |
| Вращение влево | `rotateLeft` | `rotatedLeft` |
| Найти элемент (точно) | `binarySearch` | — |
| Найти позицию (≥ ключа) | `lowerBound` | — |
| Найти позицию (> ключа) | `upperBound` | — |
| Проверить сортировку | `isSorted` | — |
| Заполнить диапазон | `fill` | — |
| Слить два отсортированных | `merge` | — |
| Декартово произведение | — | `product` |
| Следующая перестановка | `nextPermutation` | — |
| Предыдущая перестановка | `prevPermutation` | — |
