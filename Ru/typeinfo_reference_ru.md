# typeinfo.nim — Справочник модуля

> **Импорт:** `import std/typeinfo`  
> **Назначение:** Инспекция типов во время выполнения и манипуляция значениями произвольных Nim-значений через унифицированную обёртку `Any`.

---

## Предупреждение о безопасности

> **Этот модуль по своей природе небезопасен.** `Any` хранит «сырой», неотслеживаемый указатель на обёрнутое значение. Обёртка **не должна переживать** исходное значение. Неправильное использование ведёт к висячим указателям, повреждению памяти и неопределённому поведению.

Более безопасные альтернативы:
- Модуль `macros` и `getTypeImpl` — для инспекции типов **во время компиляции**.
- Обобщённые типы (generics) — для **типобезопасного** хранения произвольных значений во время выполнения.

---

## Архитектура

Устройство модуля прямолинейно: структура `Any` содержит «сырой» указатель на значение и указатель на дескриптор типа этого значения (`PNimType`). Все процедуры работают с этой парой — дескриптор типа управляет диспетчеризацией (какой cast применить, каков размер значения, какие поля существуют), а указатель на значение даёт доступ к фактическим данным для чтения или записи.

```
var myInt = 42
var a = myInt.toAny        # a.value → &myInt
                           # a.rawType → дескриптор типа `int`
echo a.kind                # → akInt
echo a.getInt              # → 42
a.setBiggestInt(99)
echo myInt                 # → 99   (исходная переменная изменена!)
```

---

## Типы

### `AnyKind`

```nim
type AnyKind* = enum
  akNone, akBool, akChar, akEnum, akArray, akObject, akTuple,
  akSet, akRange, akPtr, akRef, akSequence, akProc, akPointer,
  akString, akCString, akInt, akInt8, akInt16, akInt32, akInt64,
  akFloat, akFloat32, akFloat64, akFloat128,
  akUInt, akUInt8, akUInt16, akUInt32, akUInt64
```

Перечисление, определяющее, какой тип Nim представляет значение `Any`. `akNone` означает недействительную или неинициализированную обёртку. Значения непосредственно соответствуют внутренним идентификаторам видов типов компилятора.

---

### `Any`

```nim
type Any* = object
  value: pointer        # «сырой» указатель на обёрнутое значение
  rawTypePtr: pointer   # указатель на дескриптор типа времени выполнения
```

Универсальная обёртка. Два критических правила времени жизни:

1. **`Any` не должен переживать обёрнутую переменную.** Он хранит «сырой» указатель; когда источник выходит из области видимости, указатель становится висячим.
2. **Присваивание по умолчанию — поверхностная копия**: и оригинал, и копия указывают на одну и ту же память. Для глубокого копирования используйте `assign`.

---

## Создание `Any`

### `toAny`

```nim
proc toAny*[T](x: var T): Any
```

**Что делает.** Оборачивает `x` в `Any`. Захватывает адрес `x` напрямую — никакого копирования не происходит. `Any` и `x` разделяют одну и ту же память, поэтому мутации через обёртку затрагивают `x` и наоборот.

Параметр должен быть `var`, потому что обёртка может использоваться для изменения значения. Попытка передать `let` или литерал вызовет ошибку компилятора.

```nim
var count = 0
var a = count.toAny
assert a.kind == akInt
a.setBiggestInt(7)
assert count == 7      # оригинал изменён через обёртку
```

---

## Инспекция типа

### `kind`

```nim
proc kind*(x: Any): AnyKind
```

**Что делает.** Возвращает `AnyKind` обёрнутого значения. Первое, что нужно проверить перед вызовом любого типизированного аксессора — вызов `getInt` на значении `akFloat` вызовет сбой по assertion.

```nim
var s = "hello"
var a = s.toAny
assert a.kind == akString
```

---

### `size`

```nim
proc size*(x: Any): int
```

**Что делает.** Возвращает размер в байтах обёрнутого типа, известный исполняющей системе. Эквивалентно `sizeof(T)` для обёрнутого типа.

---

### `baseTypeKind`

```nim
proc baseTypeKind*(x: Any): AnyKind
```

**Что делает.** Возвращает `AnyKind` **базового типа** `x`. Актуально для контейнеров и производных типов: для `seq[int]` возвращает `akInt`; для `ptr T` — вид `T`. Возвращает `akNone`, если у типа нет базового.

---

### `baseTypeSize`

```nim
proc baseTypeSize*(x: Any): int
```

**Что делает.** Возвращает размер в байтах базового типа. Возвращает `0`, если базового типа нет.

---

## Управление временем жизни и памятью

### `invokeNew`

```nim
proc invokeNew*(x: Any)
```

**Что делает.** Выполняет `new(x)` во время выполнения — выделяет новый объект в куче и сохраняет его адрес через обёртку `Any`. `x` должен представлять тип `ref` (`x.kind == akRef`). После этого вызова переменная `ref`, обёрнутая в `x`, указывает на вновь выделенный объект нужного типа.

```nim
type Node = ref object
  val: int
var n: Node
var a = n.toAny
a.invokeNew           # эквивалентно: new(n)
assert not n.isNil
```

---

### `invokeNewSeq`

```nim
proc invokeNewSeq*(x: Any, len: int)
```

**Что делает.** Выполняет `newSeq(x, len)` во время выполнения — выделяет новую последовательность из `len` элементов и сохраняет её в обёрнутую переменную. `x` должен представлять последовательность (`x.kind == akSequence`). Предыдущее значение заменяется.

```nim
var s: seq[int]
var a = s.toAny
a.invokeNewSeq(5)     # эквивалентно: newSeq(s, 5)
assert s.len == 5
```

---

### `extendSeq`

```nim
proc extendSeq*(x: Any)
```

**Что делает.** Добавляет один нулевой элемент к последовательности, обёрнутой в `x`. Эквивалентно `s.setLen(s.len + 1)`. `x` должен представлять последовательность. Новый элемент занулён — его нужно установить явно через `x[x.len - 1] = value`.

```nim
var s = @[1, 2, 3]
var a = s.toAny
a.extendSeq           # s теперь @[1, 2, 3, 0]
assert a.len == 4
```

---

### `setObjectRuntimeType`

```nim
proc setObjectRuntimeType*(x: Any)
```

**Что делает.** Инициализирует поле типа времени выполнения у объекта. Необходимо вызывать после ручного выделения памяти для объекта, участвующего в диспетчеризации методов или имеющего виртуальные методы — до любых других операций с ним. `x` должен представлять тип `object`.

---

## Доступ к элементам контейнеров

### `[]` (по индексу — чтение)

```nim
proc `[]`*(x: Any, i: int): Any
```

**Что делает.** Возвращает `Any`, обёртывающий `i`-й элемент массива или последовательности. Возвращаемая обёртка указывает *внутрь* исходного контейнера — изменение через неё изменяет оригинал. Поднимает `IndexDefect` при выходе за границы. Поднимает `ValueError`, если последовательность nil.

```nim
var a = @[10, 20, 30]
var x = a.toAny
assert x[1].getInt == 20
```

---

### `[]=` (по индексу — запись)

```nim
proc `[]=`*(x: Any, i: int, y: Any)
```

**Что делает.** Устанавливает `i`-й элемент массива или последовательности. Тип элемента `y` должен совпадать с типом элемента `x` (проверяется assertion). Поднимает `IndexDefect` при выходе за границы.

```nim
var a = @[10, 20, 30]
var x = a.toAny
var v = 99
x[1] = v.toAny        # a теперь @[10, 99, 30]
```

---

### `len`

```nim
proc len*(x: Any): int
```

**Что делает.** Возвращает количество элементов в массиве или последовательности. Для массивов — статическая длина из дескриптора типа. Для последовательностей — текущая длина времени выполнения. Для nil-последовательности возвращает `0`.

```nim
var s = @[1, 2, 3]
var a = s.toAny
assert a.len == 3
```

---

### `[]` (по имени поля — чтение)

```nim
proc `[]`*(x: Any, fieldName: string): Any
```

**Что делает.** Возвращает `Any`, обёртывающий именованное поле объекта или кортежа. Поиск поля нечувствителен к стилю (те же правила, что у Nim `eqIdent`). Для объектов с наследованием поиск обходит цепочку родителей. Поднимает `ValueError`, если поле не найдено.

```nim
type Point = object
  x, y: int
var p = Point(x: 3, y: 4)
var a = p.toAny
assert a["x"].getInt == 3
```

---

### `[]=` (по имени поля — запись)

```nim
proc `[]=`*(x: Any, fieldName: string, value: Any)
```

**Что делает.** Устанавливает именованное поле объекта или кортежа в `value`. Тип `value` должен точно совпадать с типом поля (проверяется assertion). Поднимает `ValueError` для неизвестного имени поля.

```nim
var p = Point(x: 3, y: 4)
var a = p.toAny
var newY = 99
a["y"] = newY.toAny   # p.y теперь 99
```

---

### `[]` (разыменование — чтение)

```nim
proc `[]`*(x: Any): Any
```

**Что делает.** Разыменовывает `ptr` или `ref`, обёрнутый в `x`, возвращая `Any` для указуемого значения. `x` должен быть вида `akPtr` или `akRef`.

```nim
var n = new int
n[] = 42
var a = n.toAny
assert a[].getInt == 42
```

---

### `[]=` (разыменование — запись)

```nim
proc `[]=`*(x, y: Any)
```

**Что делает.** Запись через обёртку `ptr` или `ref`. `x` должен быть `akPtr`/`akRef`, тип `y` должен совпадать с указуемым типом.

---

### `base`

```nim
proc base*(x: Any): Any
```

**Что делает.** Возвращает `Any` с тем же указателем на значение, но с дескриптором типа, заменённым базовым типом. Полезно для доступа к полям родительского объекта при работе с наследованием. Указатель разделяется — данные не копируются.

---

## Чтение скалярных значений

Каждый геттер делает assertion на корректный вид перед чтением. Используйте `kind` или `baseTypeKind` для проверки перед вызовом.

### Знаковые целые

```nim
proc getInt*(x: Any): int
proc getInt8*(x: Any): int8
proc getInt16*(x: Any): int16
proc getInt32*(x: Any): int32
proc getInt64*(x: Any): int64
```

Читают точный целочисленный тип. Используйте их, когда разрядность известна заранее. Если нет — `getBiggestInt`.

---

### `getBiggestInt`

```nim
proc getBiggestInt*(x: Any): BiggestInt
```

**Что делает.** Читает любое целочисленное значение и расширяет его до `BiggestInt` (`int64`). Работает для `int`…`int64`, `uint`…`uint32`, `bool`, `char`, `enum` и малых битовых множеств. Знаковые типы знаково расширяются; беззнаковые — дополняются нулями.

```nim
var e: SomeEnum = SomeEnum.Val
var a = e.toAny
echo a.getBiggestInt   # порядковое значение Val
```

---

### `setBiggestInt`

```nim
proc setBiggestInt*(x: Any, y: BiggestInt)
```

**Что делает.** Универсальный сеттер для целых/перечислений/символов/булевых. Усекает или знаково расширяет `y` до разрядности обёрнутого типа. Работает для тех же типов, что и `getBiggestInt`.

---

### Беззнаковые целые

```nim
proc getUInt*(x: Any): uint
proc getUInt8*(x: Any): uint8
proc getUInt16*(x: Any): uint16
proc getUInt32*(x: Any): uint32
proc getUInt64*(x: Any): uint64
```

Читают точный беззнаковый целочисленный тип.

---

### `getBiggestUint`

```nim
proc getBiggestUint*(x: Any): uint64
```

**Что делает.** Читает любое беззнаковое целое значение и расширяет до `uint64`.

---

### `setBiggestUint`

```nim
proc setBiggestUint*(x: Any; y: uint64)
```

**Что делает.** Устанавливает любое беззнаковое целое, усекая `y` до нужной разрядности.

---

### `getChar`

```nim
proc getChar*(x: Any): char
```

**Что делает.** Читает значение `char`. Обрабатывает диапазонные типы, автоматически снимая обёртку диапазона.

---

### `getBool`

```nim
proc getBool*(x: Any): bool
```

**Что делает.** Читает значение `bool`. Обрабатывает диапазонные типы.

---

### Вещественные числа

```nim
proc getFloat*(x: Any): float
proc getFloat32*(x: Any): float32
proc getFloat64*(x: Any): float64
```

Читают точный тип с плавающей точкой.

---

### `getBiggestFloat`

```nim
proc getBiggestFloat*(x: Any): BiggestFloat
```

**Что делает.** Читает любое вещественное значение, расширяя до `BiggestFloat` (`float64`).

---

### `setBiggestFloat`

```nim
proc setBiggestFloat*(x: Any, y: BiggestFloat)
```

**Что делает.** Устанавливает любое вещественное значение, при необходимости сужая из `BiggestFloat`.

---

### `getString`

```nim
proc getString*(x: Any): string
```

**Что делает.** Читает значение `string`. При старом GC возвращает пустую строку для nil-строки.

---

### `setString`

```nim
proc setString*(x: Any, y: string)
```

**Что делает.** Заменяет значение `string` обёрнутой переменной на `y`.

---

### `getCString`

```nim
proc getCString*(x: Any): cstring
```

**Что делает.** Читает значение `cstring`. Возвращаемый `cstring` указывает на внешнюю C-память; за время жизни этой памяти отвечает вызывающий.

---

### `getPointer`

```nim
proc getPointer*(x: Any): pointer
```

**Что делает.** Читает «сырой» указатель из значения вида `akString`, `akCString`, `akProc`, `akRef`, `akPtr`, `akPointer` или `akSequence` (группа указателеподобных). Даёт фактический машинный адрес, а не Nim-значение.

---

### `setPointer`

```nim
proc setPointer*(x: Any, y: pointer)
```

**Что делает.** Записывает «сырой» указатель в `x`. Для не-`pointer`-видов использует `genericAssign` для GC-корректного копирования указуемого объекта; для голого `pointer` записывает адрес напрямую.

---

## Операции с перечислениями

### `getEnumOrdinal`

```nim
proc getEnumOrdinal*(x: Any, name: string): int
```

**Что делает.** Для `Any` с типом перечисления (используется только для доступа к информации о типе) ищет порядковое значение поля перечисления с именем `name`. Сравнение нечувствительно к стилю. Возвращает `low(int)`, если имя не найдено. Обрабатывает как непрерывные перечисления, так и «дырявые» (с явными порядковыми значениями).

```nim
type Color = enum Red = 0, Green = 2, Blue = 4
var c: Color
var a = c.toAny
assert a.getEnumOrdinal("Green") == 2
assert a.getEnumOrdinal("purple") == low(int)
```

---

### `getEnumField` (по порядковому значению)

```nim
proc getEnumField*(x: Any, ordinalValue: int): string
```

**Что делает.** Обратная функция к `getEnumOrdinal` — по порядковому значению возвращает имя соответствующего поля перечисления. Если порядковому значению нет соответствующего имени (напр. пробелы в дырявых перечислениях), возвращает десятичное представление числа.

```nim
var c: Color
var a = c.toAny
assert a.getEnumField(2) == "Green"
```

---

### `getEnumField` (текущее значение)

```nim
proc getEnumField*(x: Any): string
```

**Что делает.** Читает текущее порядковое значение перечисления, обёрнутого в `x`, и возвращает его имя. Совмещает `getBiggestInt` и `getEnumField(ordinal)`.

```nim
var c = Green
var a = c.toAny
assert a.getEnumField == "Green"
```

---

## Операции с множествами

### `elements` (итератор)

```nim
iterator elements*(x: Any): int
```

**Что делает.** Перебирает все элементы, присутствующие в битовом множестве, обёрнутом в `x`. Каждое возвращаемое значение — порядковый номер члена множества. `x` должен представлять тип `set`. Работает для множеств любого размера (до максимально допустимого компилятором).

```nim
type Flags = set[char]
var f: Flags = {'a', 'c', 'z'}
var a = f.toAny
for ord in a.elements:
  write(stdout, chr(ord))   # выводит: acz
```

---

### `inclSetElement`

```nim
proc inclSetElement*(x: Any, elem: int)
```

**Что делает.** Добавляет элемент с порядковым значением `elem` в битовое множество, обёрнутое в `x`. Эквивалентно `incl(s, elem)` на уровне битов. `x` должен представлять тип `set`.

```nim
var f: Flags = {}
var a = f.toAny
a.inclSetElement(ord('b'))
assert 'b' in f
```

---

## Итерация полей объектов и кортежей

### `fields` (итератор)

```nim
iterator fields*(x: Any): tuple[name: string, any: Any]
```

**Что делает.** Перебирает все **активные** поля объекта или кортежа, возвращая имя поля и `Any`, указывающий на это поле. Для объектов с вариантными (case) полями возвращаются только поля текущей активной ветви. Для объектов с наследованием включаются поля всех предков. Значения `any` в кортежах указывают непосредственно внутрь обёрнутого объекта — изменение их изменяет оригинал.

```nim
type Person = object
  name: string
  age: int

var p = Person(name: "Алиса", age: 30)
var a = p.toAny
for fieldName, fieldAny in a.fields:
  echo fieldName, ": ", fieldAny.kind
# name: akString
# age: akInt
```

---

## Глубокое присваивание

### `assign`

```nim
proc assign*(x, y: Any)
```

**Что делает.** Выполняет **глубокое копирование** значения, обёрнутого в `y`, в память, обёрнутую в `x`. Оба должны представлять один и тот же тип (проверяется assertion).

Это правильный способ скопировать значения через обёртки `Any`. Стандартное присваивание Nim на значениях `Any` копирует только пару указателей — оба `Any` оказываются указывающими на одну и ту же память, что почти никогда не является желаемым при копировании фактических данных.

```nim
var src = @[1, 2, 3]
var dst: seq[int]
assign(dst.toAny, src.toAny)   # dst теперь глубокая копия src
```

---

## Проверка на nil

### `isNil`

```nim
proc isNil*(x: Any): bool
```

**Что делает.** Возвращает `true`, если указатель, обёрнутый в `x`, равен nil. Действителен для `akCString`, `akRef`, `akPtr`, `akPointer` и `akProc`. Для других видов вызывает ошибку assertion.

```nim
var p: ptr int = nil
var a = p.toAny
assert a.isNil
```

---

## Диапазонные типы

### `skipRange`

```nim
proc skipRange*(x: Any): Any
```

**Что делает.** Для `Any` с диапазонным типом (вид `akRange`) возвращает новый `Any` с тем же указателем на значение, но с дескриптором типа, заменённым базовым — снимая ограничение диапазона. Большинство скалярных геттеров вызывают это автоматически, поэтому напрямую нужно редко.

```nim
type SmallInt = range[0..10]
var n: SmallInt = 5
var a = n.toAny
assert a.kind == akRange
var base = a.skipRange
assert base.kind == akInt
```

---

## Краткая таблица

| Задача | Процедура |
|---|---|
| Обернуть значение | `toAny` |
| Получить вид типа | `kind` |
| Получить вид базового типа | `baseTypeKind` |
| Выделить ref | `invokeNew` |
| Выделить seq | `invokeNewSeq` |
| Расширить seq на 1 | `extendSeq` |
| Индексация массива/seq | `x[i]` / `x[i] = y` |
| Доступ к полю | `x["поле"]` / `x["поле"] = y` |
| Разыменование ptr/ref | `x[]` / `x[] = y` |
| Перебор полей | итератор `fields` |
| Перебор элементов множества | итератор `elements` |
| Добавить в множество | `inclSetElement` |
| Прочитать любое целое | `getBiggestInt` |
| Записать любое целое | `setBiggestInt` |
| Прочитать любое беззнаковое | `getBiggestUint` |
| Записать любое беззнаковое | `setBiggestUint` |
| Прочитать любое вещественное | `getBiggestFloat` |
| Записать любое вещественное | `setBiggestFloat` |
| Прочитать/записать строку | `getString` / `setString` |
| Имя перечисления → порядок | `getEnumOrdinal` |
| Порядок → имя перечисления | `getEnumField(ordinal)` |
| Текущее имя перечисления | `getEnumField()` |
| Читать «сырой» указатель | `getPointer` |
| Записать «сырой» указатель | `setPointer` |
| Глубокое копирование | `assign` |
| Проверка на nil | `isNil` |
| Снять обёртку диапазона | `skipRange` |
