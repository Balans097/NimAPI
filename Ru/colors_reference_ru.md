# Справочник по модулю `colors`

> **Модуль:** `colors`  
> **Источник:** Стандартная библиотека Nim — `(c) Copyright 2010 Andreas Rumpf`  
> **Назначение:** Представление цветов, арифметика над ними, разбор строк и конвертация. Предоставляет палитру именованных CSS/X11-цветов в виде констант времени компиляции.

---

## Обзор

Модуль `colors` строится вокруг одного типа — `Color`, — который хранит цвет как 24-битное целое число RGB в привычном формате `0xRRGGBB`. Всё остальное является надстройкой: операторы для объединения цветов, вспомогательные функции для разложения по каналам, масштабирование яркости, гибкий шаблон пользовательского смешивания, а также разбор строк в форматах `#RRGGBB` и именованных CSS-цветов.

Ключевая особенность дизайна — **насыщенная арифметика**: сложение и вычитание цветов зажимают каждый канал в диапазоне `[0, 255]` вместо переполнения по кругу, что соответствует естественным ожиданиям при работе с цветами на экране.

---

## Тип

### `Color`

```nim
type Color* = distinct int
```

24-битный цвет, хранимый как обычный `int` с раскладкой `0x00RRGGBB`:

- Биты 23–16 → Красный канал (0–255)
- Биты 15–8  → Зелёный канал (0–255)
- Биты 7–0   → Синий канал (0–255)

Поскольку `Color` является `distinct int`, его невозможно случайно перепутать с обычным целым числом. Для работы с ним необходимо использовать операторы и конструкторы из данного модуля. Альфа-канал не поддерживается — модуль работает только с непрозрачным RGB.

---

## Экспортируемые символы

| Символ | Вид | Краткое описание |
|--------|-----|-----------------|
| `==` | оператор | Сравнение двух цветов на равенство |
| `+` | оператор | Насыщенное поканальное сложение |
| `-` | оператор | Насыщенное поканальное вычитание |
| `$` | оператор | Конвертация в строку `"#RRGGBB"` |
| `rgb` | proc | Создание `Color` из трёх значений каналов |
| `extractRGB` | proc | Разложение `Color` на кортеж `(r, g, b)` |
| `intensity` | proc | Масштабирование яркости вещественным множителем |
| `mix` | шаблон | Применение пользовательской функции к каждой паре каналов |
| `parseColor` | proc | Разбор строки `"name"` или `"#RRGGBB"` в `Color` |
| `isColor` | proc | Проверка, является ли строка допустимым цветом |
| Именованные константы | `const` | ~140 CSS/X11 цветов, например `colRed`, `colSkyBlue` |

---

## Операторы

### `==`

```nim
proc `==`*(a, b: Color): bool
```

Сравнивает два цвета на равенство. Заимствован от сравнения `int`, то есть выполняет побитовую проверку полного RGB-значения.

```nim
assert colFuchsia == Color(0xFF00FF)   # одинаковые биты → равны
assert colRed != colBlue               # разные биты → не равны

let a = Color(0xFF00FF)
let b = colFuchsia
assert a == b   # именованная константа совпадает с hex-литералом
```

---

### `+`  — Насыщенное сложение

```nim
proc `+`*(a, b: Color): Color
```

Складывает два цвета **поканально**. Результат каждого канала ограничивается 255, если превышает это значение — переполнения не происходит. Это делает оператор безопасным: не нужно беспокоиться о получении бессмысленных цветов при переполнении.

Можно думать об этом как о «добавлении оттенка»: добавление небольшого оранжевого тона к тёмно-синему немного сдвинет его в сторону тёплых тонов без «зашкаливания» ни одного канала.

```nim
let dark  = Color(0xAA_00_FF)   # R=170 G=0   B=255
let tint  = Color(0x11_CC_CC)   # R=17  G=204 B=204
let mixed = dark + tint
# R: 170+17=187 (0xBB), G: 0+204=204 (0xCC), B: 255+204→зажато до 255 (0xFF)
assert mixed == Color(0xBB_CC_FF)

# Насыщение в действии:
let white = Color(0xFF_FF_FF)
assert white + white == white   # все каналы на максимуме, ничего не меняется
```

---

### `-`  — Насыщенное вычитание

```nim
proc `-`*(a, b: Color): Color
```

Вычитает два цвета поканально. Результат каждого канала ограничивается снизу нулём. Это дополнение к `+`: используется для затемнения или удаления оттенка.

```nim
let a      = Color(0xFF_33_FF)   # R=255 G=51  B=255
let b      = Color(0x11_FF_CC)   # R=17  G=255 B=204
let result = a - b
# R: 255-17=238 (0xEE), G: 51-255→зажато до 0 (0x00), B: 255-204=51 (0x33)
assert result == Color(0xEE_00_33)

# Защита от отрицательных значений:
assert colBlack - colWhite == colBlack   # ниже 0 опуститься нельзя
```

---

### `$`  — Конвертация в строку

```nim
proc `$`*(c: Color): string
```

Преобразует значение `Color` в каноническую строку шестнадцатеричного формата `"#RRGGBB"` в верхнем регистре. Удобно для вывода цветов в HTML, CSS или лог-файлы. Префикс `#` всегда присутствует, буквы всегда в верхнем регистре.

```nim
echo $colFuchsia      # → "#FF00FF"
echo $colBlack        # → "#000000"
echo $Color(0x1a2b3c) # → "#1A2B3C"
```

Это обратная операция к `parseColor` для формата `#RRGGBB`.

---

## Конструкторы

### `rgb`

```nim
proc rgb*(r, g, b: range[0..255]): Color
```

Наиболее читаемый способ создать `Color` из отдельных значений каналов. Каждый аргумент имеет тип `range[0..255]`, поэтому передача значения за пределами диапазона является ошибкой на этапе компиляции или выполнения — нельзя случайно создать некорректный цвет.

```nim
let c = rgb(255, 128, 0)   # оранжевый: R=255, G=128, B=0
assert c == Color(0xFF_80_00)

let navy = rgb(0, 0, 128)
assert navy == colNavy

# Диапазон проверяется принудительно:
# rgb(300, 0, 0)  ← не скомпилируется / вызовет RangeDefect в рантайме
```

Используйте `rgb`, когда значения каналов приходят из отдельных переменных или вычислений. Используйте литерал `Color(0xRRGGBB)`, когда hex-значение уже известно.

---

## Декомпозиция

### `extractRGB`

```nim
proc extractRGB*(a: Color): tuple[r, g, b: range[0..255]]
```

Разбивает `Color` обратно на три значения каналов. Возвращает именованный кортеж с полями `r`, `g`, `b`, каждое с типом `range[0..255]`. Это обратная операция к `rgb`.

Используйте эту функцию, когда нужно инспектировать или обрабатывать отдельные каналы — например, для перевода в HSL, сравнения яркости или форматирования цвета как `rgb(R, G, B)` для CSS.

```nim
let c = Color(0xFF_00_FF)   # фуксия
let (r, g, b) = extractRGB(c)
assert r == 255
assert g == 0
assert b == 255

# Обращение по именам полей:
let ch = extractRGB(colSkyBlue)
echo ch.r, " ", ch.g, " ", ch.b   # → 135 206 235

# Кругооборот: rgb ↔ extractRGB
let original = rgb(10, 200, 50)
let (ro, go, bo) = extractRGB(original)
assert rgb(ro, go, bo) == original
```

---

## Яркость

### `intensity`

```nim
proc intensity*(a: Color, f: float): Color
```

Масштабирует каждый канал цвета `a` на множитель `f`. Ожидаемый диапазон `f`: от `0.0` (полная темнота — все каналы становятся 0) до `1.0` (без изменений). Значения чуть выше 1.0 допустимы, так как каждый канал ограничивается 255 при переполнении, но очень большие или отрицательные значения дадут непредсказуемый результат.

Концептуально это моделирует, как свет освещает поверхность, окрашенную данным цветом: при `f = 0.5` сохраняется тот же оттенок, но вдвое темнее; при `f = 0.0` всегда получается чёрный.

```nim
assert colWhite.intensity(0.5) == Color(0x80_80_80)   # средне-серый
assert colWhite.intensity(0.0) == colBlack             # полная темнота
assert colWhite.intensity(1.0) == colWhite             # без изменений

let fuchsia = Color(0xFF_00_FF)
assert fuchsia.intensity(0.5) == Color(0x80_00_80)   # 255*0.5=127 → 0x7F, но по факту 0x80

let teal = Color(0x00_42_CC)
assert teal.intensity(0.5) == Color(0x00_21_66)
```

> **Замечание:** Округление производится через `toInt(toFloat(канал) * f)`, что усекает к нулю. Для канала 255 при f=0.5: `toInt(255.0 * 0.5)` = `toInt(127.5)` = `127` (0x7F), а не 128. Результат в конкретном примере зависит от значения канала — всегда проверяйте на реальных данных.

---

## Пользовательское смешивание

### `mix`

```nim
template mix*(a, b: Color, fn: untyped): untyped
```

Наиболее мощный и универсальный инструмент смешивания цветов в модуле. `mix` вызывает вашу функцию `fn` для каждой пары соответствующих каналов — `(aR, bR)`, `(aG, bG)`, `(aB, bB)` — и собирает результаты в новый `Color`. Каждый результат ограничивается диапазоном `[0, 255]` вне зависимости от того, что возвращает ваша функция.

`fn` должна принимать два аргумента типа `int` и возвращать `int`. Вычисляется три раза — по одному на канал. Поскольку `fn` — параметр типа `untyped`, можно передавать любой вызываемый объект: именованную процедуру, лямбду или даже встроенный шаблон.

Этот механизм покрывает сценарии, недоступные через `+` и `-`: режим Screen, Multiply, Difference, произвольные взвешенные средние и т.д.

```nim
# Простое среднее (смешивание 50/50)
proc avg(x, y: int): int = (x + y) div 2
let blended = mix(colRed, colBlue, avg)
# R: (255+0)/2=127, G: (0+0)/2=0, B: (0+255)/2=127
assert blended == Color(0x7F_00_7F)

# Режим "Screen": 1 - (1-a)(1-b)  → выражено через целые числа
proc screen(x, y: int): int =
  255 - ((255 - x) * (255 - y)) div 255
let s = mix(Color(0x80_80_80), Color(0x80_80_80), screen)
assert s == Color(0xBF_BF_BF)

# Отрицательный результат → ограничивается нулём
proc myMix(x, y: int): int = 2 * x - 3 * y
let a = Color(0x0A_28_14)
let b = Color(0x05_0A_03)
assert mix(a, b, myMix) == Color(0x05_32_1F)
```

---

## Разбор и валидация

### `parseColor`

```nim
proc parseColor*(name: string): Color
```

Преобразует строку в `Color`. Принимаются два формата:

- **Именованные CSS-цвета** — без учёта регистра, например `"red"`, `"SkyBlue"`, `"GOLDENROD"`. Внутри поиск выполняется бинарным поиском по отсортированной таблице `colorNames`.
- **Hex-литерал** — строка, начинающаяся с `#`, за которой следуют до 6 hex-цифр, например `"#FF00FF"`, `"#0179fc"`. Разбирается с помощью `parseHexInt`.

Вызывает `ValueError`, если строка не является ни известным именем, ни допустимой hex-строкой.

```nim
assert parseColor("silver")  == Color(0xC0_C0_C0)
assert parseColor("Silver")  == Color(0xC0_C0_C0)   # без учёта регистра
assert parseColor("SILVER")  == Color(0xC0_C0_C0)

assert parseColor("#0179fc") == Color(0x01_79_FC)
assert parseColor("#FF00FF") == colFuchsia

# Некорректный ввод:
try:
  discard parseColor("#zzmmtt")
except ValueError as e:
  echo e.msg   # сообщение от parseHexInt

try:
  discard parseColor("notacolor")
except ValueError as e:
  echo e.msg   # → "unknown color: notacolor"
```

> **Совет:** Если вы не уверены в корректности строки, сначала вызовите `isColor`, чтобы не ловить исключения в горячих путях.

---

### `isColor`

```nim
proc isColor*(name: string): bool
```

Валидатор без исключений: возвращает `true`, если `name` является либо известным CSS-именем цвета, либо синтаксически корректной hex-строкой с префиксом `#`. Никаких исключений — для нераспознанного ввода просто возвращается `false`.

Проверка hex-строки убеждается, что каждый символ после `#` является hex-цифрой (`0–9`, `a–f`, `A–F`). Пустая строка возвращает `false`.

```nim
assert "silver".isColor       # известное CSS-имя
assert "#0179fc".isColor      # допустимый hex
assert "#FFFFFF".isColor      # hex в верхнем регистре
assert not "#zzmmtt".isColor  # 'z' и 'm' — не hex-цифры
assert not "".isColor         # пустая строка
assert not "electricpink".isColor  # нет в CSS-палитре

# Типичное применение: проверить перед разбором
let input = getUserInput()
if input.isColor:
  let c = parseColor(input)
  draw(c)
else:
  echo "Недопустимый цвет: " & input
```

---

## Именованные константы цветов

Модуль экспортирует около 140 CSS/X11-констант цвета, все с префиксом `col`. Это значения `const` времени компиляции типа `Color`.

Несколько показательных примеров:

| Константа | Hex-значение | Приблизительный оттенок |
|----------|-------------|------------------------|
| `colBlack` | `0x000000` | Чёрный |
| `colWhite` | `0xFFFFFF` | Белый |
| `colRed` | `0xFF0000` | Чистый красный |
| `colGreen` | `0x008000` | CSS-зелёный (тёмный) |
| `colLime` | `0x00FF00` | Чистый ярко-зелёный |
| `colBlue` | `0x0000FF` | Чистый синий |
| `colFuchsia` / `colMagenta` | `0xFF00FF` | Маджента (два псевдонима) |
| `colCyan` / `colAqua` | `0x00FFFF` | Голубой (два псевдонима) |
| `colGray` / `colGrey` | `0x808080` | Средне-серый (два псевдонима) |
| `colCornflowerBlue` | `0x6495ED` | Мягкий синий |
| `colRebeccaPurple` | `0x663399` | Средне-фиолетовый |
| `colTomato` | `0xFF6347` | Оранжево-красный |
| `colGold` | `0xFFD700` | Ярко-золотой |

Некоторые CSS-цвета имеют как американское написание (`Gray`), так и британское (`Grey`) — это идентичные значения, доступные под двумя именами.

```nim
# Именованные константы повышают читаемость
let background = colMidnightBlue
let highlight  = colGold
let shadow     = background.intensity(0.3)
```

---

## Типичные паттерны использования

### Создание палитры из CSS-имён

```nim
let palette = ["tomato", "steelblue", "goldenrod", "mediumseagreen"]
for name in palette:
  let c = parseColor(name)
  echo name, " → ", $c
```

### Осветление и затемнение

```nim
let base  = colSteelBlue
let light = base.intensity(1.5)   # переэкспонирован (каналы зажаты до 255)
let dark  = base.intensity(0.4)   # более тёмный оттенок
```

### Пользовательский режим Screen

```nim
proc screen(a, b: int): int =
  255 - ((255 - a) * (255 - b)) div 255

let overlay = mix(colCornflowerBlue, colTomato, screen)
```

### Разложение и пересборка с гамма-коррекцией

```nim
proc gammaCorrect(c: Color, gamma: float): Color =
  let (r, g, b) = extractRGB(c)
  let f = proc (ch: int): int =
    toInt(pow(ch.float / 255.0, gamma) * 255.0)
  rgb(f(r), f(g), f(b))
```

---

## Таблица ошибок

| Ситуация | Исключение | Шаблон сообщения |
|----------|-----------|-----------------|
| Неизвестное имя в `parseColor` | `ValueError` | `"unknown color: <n>"` |
| Некорректная hex-строка в `parseColor` | `ValueError` | вызывается из `parseHexInt` |
| Значение канала вне `[0..255]` в `rgb` | `RangeDefect` | вызывается проверкой диапазона |
