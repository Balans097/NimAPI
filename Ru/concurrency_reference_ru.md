# Nim — Примитивы параллелизма: Справочник по модулям

> **Требования к компиляции:** Все модули требуют флага `--threads:on`.  
> `channels` дополнительно требует `--mm:arc`, `--mm:atomicArc` или `--mm:orc`.  
> `atomics` устарел — в новом коде используйте `std/atomics`.

Этот справочник охватывает все семь модулей параллелизма. Разделы упорядочены от низкоуровневых примитивов к высокоуровневым паттернам координации — так строится типичная многопоточная система.

---

## Содержание

1. [atomics — Атомарные операции без блокировок](#atomics)
2. [channels — Типизированные очереди сообщений](#channels)
3. [semaphore — Управление доступом через счётчик](#semaphore)
4. [barrier — Синхронизация фаз для фиксированной группы потоков](#barrier)
5. [rwlock — Блокировка чтения-записи](#rwlock)
6. [once — Одноразовая инициализация](#once)
7. [waitgroups — Ожидание динамического набора рабочих потоков](#waitgroups)
8. [Как выбрать примитив](#как-выбрать-примитив)

---

## atomics

> **Модуль:** `atomics`  
> ⚠️ **Устарел** — это старый интерфейс. В новом коде используйте `import std/atomics`.  
> Требует: `--threads:on`

Атомарные операции работают с отдельными ячейками памяти без использования блокировок. Они — фундамент любого алгоритма без блокировок. Ключевая гарантия: ни один поток никогда не увидит объект в «полуизменённом» состоянии. Чтение или запись либо происходят целиком, либо не происходят вовсе — с точки зрения любого другого потока.

### Понимание порядка памяти

Каждая атомарная операция принимает необязательный параметр `order: Ordering`, который контролирует, в каком порядке CPU или компилятор могут переупорядочивать соседние неатомарные операции. Это самая сложная часть программирования без блокировок.

```
Relaxed  ──────────────────────────────────────────  Слабейший (быстрейший)
Consume  (не рекомендуется — используйте Acquire)
Acquire  (для загрузок: ничто не перемещается перед этой операцией)
Release  (для сохранений: ничто не перемещается после этой операции)
AcqRel   (Acquire + Release для операций чтения-изменения-записи)
SeqCst   ──────────────────────────────────────────  Сильнейший (по умолчанию)
```

### Тип: `Ordering`

```nim
type Ordering* {.pure.} = enum
  Relaxed, Consume, Acquire, Release, AcqRel, SeqCst
```

Задаёт ограничения видимости и упорядочивания, которые CPU обязан соблюдать вокруг одной атомарной операции. Когда сомневаетесь, оставляйте параметр при значении `SeqCst` по умолчанию — это самый безопасный и простой для рассуждений вариант, пусть и с некоторыми накладными расходами.

| Значение | Типичное применение |
|---|---|
| `Relaxed` | Независимые счётчики, где порядок относительно других данных неважен (например, статистика) |
| `Acquire` | Загрузка, которая «захватывает» владение — пара к `Release`-сохранению в другом месте |
| `Release` | Сохранение, публикующее данные — пара к `Acquire`-загрузке в другом месте |
| `AcqRel` | Операции чтения-изменения-записи (например, `fetchAdd` на общем ресурсе) |
| `SeqCst` | По умолчанию. Все потоки видят единый полный порядок всех `SeqCst`-операций |

---

### Тип: `Atomic[T]`

```nim
type Atomic*[T: AtomType] = distinct T
```

Обёртка над значением типа `T`, гарантирующая атомарность всех обращений. `T` должен быть `AtomType` — на практике это целые числа, булевы значения и типы размером с указатель. Атомарно работать со сложными структурами невозможно.

```nim
var counter: Atomic[int]
var flag: Atomic[bool]
```

---

### `load`

```nim
proc load*[T](location: var Atomic[T]; order: Ordering = SeqCst): T
```

Читает текущее значение атомарного объекта и возвращает его. Параметр `order` должен быть `Relaxed`, `Consume`, `Acquire` или `SeqCst` — `Release` и `AcqRel` к загрузкам неприменимы.

```nim
var x: Atomic[int]
x.store(42)
echo x.load()           # 42, с полным SeqCst-упорядочиванием
echo x.load(Relaxed)    # 42, дешевейшее чтение, когда порядок неважен
```

---

### `store`

```nim
proc store*[T](location: var Atomic[T]; desired: T; order: Ordering = SeqCst)
```

Атомарно записывает `desired` в атомарный объект. Допустимые порядки: `Relaxed`, `Release`, `SeqCst`.

```nim
var flag: Atomic[bool]
flag.store(true)           # публикация с полным SeqCst
flag.store(false, Release) # Release: все предшествующие записи видны другим потокам
```

---

### `exchange`

```nim
proc exchange*[T](location: var Atomic[T]; desired: T; order: Ordering = SeqCst): T
```

Атомарно заменяет текущее значение на `desired` и возвращает **старое** значение. Полезно для захвата владения ресурсом.

```nim
var x: Atomic[int]
x.store(10)
let old = x.exchange(99)
assert old == 10
assert x.load() == 99
```

---

### `compareExchange`

```nim
proc compareExchange*[T](location: var Atomic[T]; expected: var T; desired: T;
    order: Ordering = SeqCst): bool

proc compareExchange*[T](location: var Atomic[T]; expected: var T; desired: T;
    success, failure: Ordering): bool
```

Фундаментальный строительный блок алгоритмов без блокировок. Атомарно выполняет следующее как единое неделимое действие:

1. Сравнивает текущее значение `location` с `expected`.
2. **Если совпадают:** записывает `desired` в `location`, возвращает `true`. `expected` не меняется.
3. **Если не совпадают:** загружает текущее значение `location` в `expected`, возвращает `false`. `location` не меняется.

Перегрузка с двумя порядками позволяет задать отдельные ограничения для пути успеха и пути неудачи — это может быть эффективнее.

```nim
var x: Atomic[int]
x.store(5)

var expected = 5
if x.compareExchange(expected, 100):
  echo "обменяли: x теперь 100"
else:
  echo "не удалось: x был", expected, "а не 5"

# Типичный паттерн CAS-цикла — крутимся до успеха:
var cur = x.load(Relaxed)
while not x.compareExchange(cur, cur * 2, Relaxed, Relaxed):
  discard  # cur обновлён фактическим значением; повторяем
```

---

### `compareExchangeWeak`

```nim
proc compareExchangeWeak*[T](location: var Atomic[T]; expected: var T;
    desired: T; order: Ordering = SeqCst): bool

proc compareExchangeWeak*[T](location: var Atomic[T]; expected: var T;
    desired: T; success, failure: Ordering): bool
```

Та же семантика, что у `compareExchange`, но допускает **ложный провал** даже когда текущее значение равно `expected`. Это напрямую отражает инструкцию `LL/SC` (load-linked/store-conditional) на архитектурах вроде ARM, где операция иногда проваливается по микроархитектурным причинам, не связанным с конкуренцией.

В цикле повторных попыток `compareExchangeWeak` зачастую быстрее сильного варианта на таких архитектурах, поскольку не требует лишнего сравнения. Используйте сильный `compareExchange`, когда делается единственная попытка без цикла.

```nim
var cur = x.load(Relaxed)
while not x.compareExchangeWeak(cur, cur + 1, AcqRel, Relaxed):
  discard  # ложный или реальный провал; cur обновлён; повторяем
```

---

### `fetchAdd`

```nim
proc fetchAdd*[T: SomeInteger](location: var Atomic[T]; value: T;
    order: Ordering = SeqCst): T
```

Атомарно прибавляет `value` к целому числу и возвращает **исходное** (до прибавления) значение. Канонический способ генерации уникальных ID или индексов между потоками без блокировки.

```nim
var idGen: Atomic[int]
let myId = idGen.fetchAdd(1)  # возвращает 0, 1, 2, ... для каждого вызывающего
```

---

### `fetchSub`

```nim
proc fetchSub*[T: SomeInteger](location: var Atomic[T]; value: T;
    order: Ordering = SeqCst): T
```

Атомарно вычитает `value` и возвращает исходное значение. Часто используется в подсчёте ссылок: когда возвращённое значение равно 1 (то есть теперь оно стало 0), именно этот вызывающий отвечает за освобождение ресурса.

```nim
var refCount: Atomic[int]
refCount.store(3)
if refCount.fetchSub(1) == 1:  # было 1, стало 0
  echo "последняя ссылка — освобождаем объект"
```

---

### `fetchAnd`

```nim
proc fetchAnd*[T: SomeInteger](location: var Atomic[T]; value: T;
    order: Ordering = SeqCst): T
```

Атомарно заменяет значение на `location AND value` и возвращает исходное. Применяется для атомарного сброса отдельных битов.

```nim
var flags: Atomic[uint32]
flags.store(0b1111'u32)
let before = flags.fetchAnd(0b1100'u32)  # сбрасываем биты 0 и 1
assert flags.load() == 0b1100'u32
```

---

### `fetchOr`

```nim
proc fetchOr*[T: SomeInteger](location: var Atomic[T]; value: T;
    order: Ordering = SeqCst): T
```

Атомарно заменяет значение на `location OR value` и возвращает исходное. Применяется для атомарной установки отдельных битов.

```nim
var flags: Atomic[uint32]
flags.store(0b0000'u32)
discard flags.fetchOr(0b0011'u32)  # устанавливаем биты 0 и 1
assert flags.load() == 0b0011'u32
```

---

### `fetchXor`

```nim
proc fetchXor*[T: SomeInteger](location: var Atomic[T]; value: T;
    order: Ordering = SeqCst): T
```

Атомарно заменяет значение на `location XOR value` и возвращает исходное. Применяется для атомарного переключения отдельных битов.

```nim
var flags: Atomic[uint32]
flags.store(0b1010'u32)
discard flags.fetchXor(0b1100'u32)
assert flags.load() == 0b0110'u32
```

---

### `atomicInc`

```nim
proc atomicInc*[T: SomeInteger](location: var Atomic[T]; value: T = 1)
```

Атомарно увеличивает `location` на `value` (по умолчанию 1). Удобная обёртка над `fetchAdd`, отбрасывающая возвращаемое значение. Используйте, когда значение до инкремента вам не нужно.

```nim
var hits: Atomic[int]
hits.atomicInc()       # += 1
hits.atomicInc(5)      # += 5
```

---

### `atomicDec`

```nim
proc atomicDec*[T: SomeInteger](location: var Atomic[T]; value: T = 1)
```

Атомарно уменьшает `location` на `value` (по умолчанию 1). Удобная обёртка над `fetchSub`.

```nim
var remaining: Atomic[int]
remaining.store(10)
remaining.atomicDec()
```

---

### `+=` и `-=`

```nim
proc `+=`*[T: SomeInteger](location: var Atomic[T]; value: T)
proc `-=`*[T: SomeInteger](location: var Atomic[T]; value: T)
```

Операторный синтаксис для `atomicInc` и `atomicDec`. Особенно читаемо в последовательном коде с атомарными счётчиками.

```nim
var score: Atomic[int]
score += 10
score -= 3
echo score.load()  # 7
```

---

## channels

> **Модуль:** `channels`  
> ⚠️ **Экспериментальный** — интерфейс может измениться.  
> Требует: `--threads:on --mm:arc` (или `--mm:atomicArc` или `--mm:orc`)

Канал — это типизированная, потокобезопасная очередь FIFO. Он реализует стиль конкурентности «взаимодействующих последовательных процессов» (CSP): вместо того чтобы делить память, защищённую блокировкой, потоки владеют своими данными эксклюзивно и передают владение через канал. Обёртка `Isolated[T]` (из `std/isolation`) обеспечивает это на уровне типов — данные, переданные через канал, **перемещаются**, а не копируются.

`Chan[T]` — это разделяемый дескриптор с подсчётом ссылок. Его можно свободно копировать и передавать в потоки — все копии ссылаются на одну и ту же очередь. Очередь освобождается, когда уничтожается последняя копия.

---

### `newChan`

```nim
proc newChan*[T](elements: Positive = 30): Chan[T]
```

Создаёт и инициализирует новый канал с ёмкостью буфера `elements` сообщений. Это **единственный** способ создать валидный `Chan[T]`. Внутренняя очередь выделяется в разделяемой памяти, чтобы к ней могли обращаться любые потоки.

`elements` — максимальное количество сообщений, которые одновременно могут находиться в очереди. Если все слоты заняты:
- `send` блокируется до тех пор, пока получатель не освободит слот.
- `trySend` немедленно возвращает `false`.

```nim
var ch = newChan[string]()      # ёмкость 30
var smallCh = newChan[int](4)   # ёмкость 4 — строгое обратное давление
```

---

### `send`

```nim
proc send*[T](c: Chan[T], src: sink Isolated[T])
template send*[T](c: Chan[T]; src: T)
```

Отправляет сообщение в канал. **Блокируется**, если канал полон, ожидая, пока получатель не освободит место. Данные **перемещаются** в канал — не используйте `src` после отправки.

Форма-шаблон автоматически оборачивает `src` в `isolate()`, что проверяет на этапе компиляции, что значение не содержит ссылок на локальные для потока данные. Используйте форму-шаблон для простых значений и небольших объектов.

```nim
var ch = newChan[string]()

# Из рабочего потока:
ch.send("hello")            # форма-шаблон — наиболее удобна

# Для объектов, которые нельзя скопировать, используйте явную изоляцию:
import std/isolation
ch.send(isolate(myString))
```

---

### `recv`

```nim
proc recv*[T](c: Chan[T], dst: var T)
proc recv*[T](c: Chan[T]): T
```

Получает сообщение из канала. **Блокируется**, если канал пуст, ожидая, пока отправитель не положит сообщение. Предоставляются две формы:

- **Форма на месте** (`dst: var T`): записывает напрямую в существующую переменную.
- **Форма с возвратом**: создаёт новое значение и возвращает его. Немного эргономичнее, но требует лишнего перемещения в некоторых случаях.

```nim
var ch = newChan[string]()
ch.send("world")

var msg: string
ch.recv(msg)          # форма на месте
echo msg              # "world"

let msg2 = ch.recv()  # форма с возвратом
```

---

### `recvIso`

```nim
proc recvIso*[T](c: Chan[T]): Isolated[T]
```

Как `recv`, но возвращает значение, обёрнутое в `Isolated[T]`. Полезно, когда полученное значение нужно сразу передать в другой канал или другую границу изоляции без предварительного разворачивания.

```nim
var ch = newChan[string]()
ch.send("данные")
let iso = ch.recvIso()
# можно сразу передать в другой канал:
# otherChan.send(iso)
```

---

### `trySend`

```nim
proc trySend*[T](c: Chan[T], src: sink Isolated[T]): bool
template trySend*[T](c: Chan[T], src: T): bool
```

Пытается отправить сообщение без блокировки. Возвращает `true`, если сообщение помещено в канал, `false` — если канал полон. При успехе данные перемещаются; при неудаче владение остаётся у вызывающего.

В условиях высокой конкуренции рассмотрите **экспоненциальный откат** в цикле повторных попыток для снижения инвалидации кешевых линий.

```nim
var ch = newChan[int](2)
assert ch.trySend(1) == true
assert ch.trySend(2) == true
assert ch.trySend(3) == false  # полный
```

---

### `tryTake`

```nim
proc tryTake*[T](c: Chan[T], src: var Isolated[T]): bool
```

Неблокирующий вариант отправки, работающий непосредственно с переменной `Isolated[T]`, перемещая её без копирования. Подходит для типов, которые нельзя скопировать (то есть с удалённым хуком `=copy`). Возвращает `true` при успехе.

```nim
import std/isolation
var ch = newChan[string](5)
var iso = isolate("некопируемые данные")
if ch.tryTake(iso):
  echo "отправлено"
```

---

### `tryRecv`

```nim
proc tryRecv*[T](c: Chan[T], dst: var T): bool
```

Пытается получить сообщение без блокировки. Возвращает `true` и записывает полученное значение в `dst`, если сообщение доступно; возвращает `false` и оставляет `dst` неизменным в противном случае.

Канонический паттерн опрашивающего потребителя: выполняйте полезную работу между попытками, а не занимайтесь активным ожиданием.

```nim
var ch = newChan[string]()
var msg: string
while not ch.tryRecv(msg):
  doOtherWork()
echo "получено:", msg
```

---

### `peek`

```nim
proc peek*[T](c: Chan[T]): int
```

Возвращает **оценку** текущего количества сообщений в канале. Поскольку другие потоки могут одновременно отправлять или получать сообщения, значение может устареть к моменту чтения. Не используйте `peek` для управления потоком выполнения там, где нужна корректность (используйте `tryRecv`). Подходит для мониторинга, журналирования и эвристик обратного давления.

```nim
var ch = newChan[int](10)
ch.send(1); ch.send(2)
echo ch.peek()  # вероятно 2, но не гарантировано
```

---

## semaphore

> **Модуль:** `semaphore`  
> Требует: `--threads:on`

Семафор — обобщённая блокировка. Там, где мьютекс допускает ровно один поток одновременно, семафор допускает **до N потоков одновременно**, управляемых счётчиком. Когда счётчик достигает нуля, `wait` блокируется до тех пор, пока другой поток не вызовет `signal`, восстанавливая единицу.

Два канонических применения:
- **Считающий семафор** (N > 1): ограничить одновременный доступ к пулу ресурсов (например, соединения с базой данных, слоты воркеров).
- **Бинарный семафор** (N = 1): простой механизм сигнализации — один поток ждёт, другой сигнализирует. В отличие от мьютекса, сигнализирующий поток не обязан совпадать с ожидающим.

---

### Тип: `Semaphore`

```nim
type Semaphore* = object
```

Содержит счётчик, мьютекс и условную переменную. Нельзя копировать или перемещать — после создания должен оставаться по фиксированному адресу памяти.

---

### `createSemaphore`

```nim
proc createSemaphore*(count: Natural = 0): Semaphore
```

Создаёт семафор, инициализированный значением `count`. Единственный допустимый способ получить `Semaphore`.

- `count = 0` — первый поток, вызвавший `wait`, немедленно заблокируется. Используйте как одноразовое уведомление: ожидающий поток разблокируется только после вызова `signal` другим потоком.
- `count = N` — до N потоков могут вызвать `wait` и пройти без блокировки. Используйте, чтобы ограничить конкурентность N одновременными операциями.

```nim
var pool = createSemaphore(3)  # допустить не более 3 одновременных воркеров
var gate = createSemaphore(0)  # барьер: ждать до сигнала
```

---

### `wait` (Semaphore)

```nim
proc wait*(s: var Semaphore)
```

Уменьшает счётчик семафора на 1. Если счётчик уже равен 0, вызывающий поток блокируется до тех пор, пока другой поток не вызовет `signal`. После разблокировки поток уменьшает счётчик и продолжает работу.

```nim
# Рабочий поток: захватить слот из пула
pool.wait()
try:
  doExpensiveWork()
finally:
  pool.signal()  # освободить слот
```

---

### `signal`

```nim
proc signal*(s: var Semaphore)
```

Увеличивает счётчик семафора на 1 и будит один ожидающий поток (если есть). `signal` может вызываться из потока, отличного от того, который вызвал `wait` — именно это отличает семафор от мьютекса.

```nim
# После завершения задачи вернуть слот в пул:
pool.signal()

# Сигнализировать ожидающему потоку о наступлении события:
gate.signal()
```

---

## barrier

> **Модуль:** `barrier`  
> Требует: `--threads:on`

Барьер — это точка встречи для фиксированного, заранее объявленного числа потоков. Каждый поток, вызвавший `wait` на барьере, блокируется до тех пор, пока **все** объявленное число потоков не вызовут `wait`. В этот момент все потоки освобождаются одновременно, а барьер автоматически **сбрасывается** в исходное состояние, готовый к следующему раунду. Это называется *циклическим барьером*.

Барьеры идеальны для поэтапных алгоритмов, где каждый поток должен завершить фазу N, прежде чем любой из них начнёт фазу N+1.

---

### Тип: `Barrier`

```nim
type Barrier* = object
```

Содержит внутренний счётчик, блокировку и условную переменную. Нельзя копировать или перемещать.

---

### `createBarrier`

```nim
proc createBarrier*(parties: Natural): Barrier
```

Создаёт барьер, требующий `parties` потоков для вызова `wait` перед освобождением. `parties` должно точно соответствовать числу участвующих потоков и не должно меняться после создания.

```nim
var b = createBarrier(4)  # 4 потока должны прибыть прежде, чем любой продолжит
```

---

### `wait` (Barrier)

```nim
proc wait*(b: var Barrier)
```

Сигнализирует, что вызывающий поток достиг барьера, а затем блокируется до тех пор, пока все остальные потоки не сделают то же самое. Последний прибывший поток сбрасывает барьер и будит всех ожидающих. После этого каждый поток возвращается из `wait` и продолжает работу.

Циклическая природа барьера означает, что `wait` можно вызывать в цикле, синхронизируясь на каждой итерации, не пересоздавая барьер.

```nim
var b = createBarrier(10)

proc phaseWorker(id: int) =
  for phase in 0..<100:
    doPhaseWork(id, phase)
    b.wait()  # дождаться завершения всеми перед переходом к следующей фазе
```

---

## rwlock

> **Модуль:** `rwlock`  
> Требует: `--threads:on`

Блокировка чтения-записи (разделяемо-исключительная блокировка) различает два типа доступа:

- **Читатели** удерживают *разделяемую* блокировку. Любое количество читателей может удерживать её одновременно.
- **Писатели** удерживают *исключительную* блокировку. Пока писатель удерживает блокировку, никакие читатели и другие писатели не могут продолжать работу.

Это идеально для структур данных, которые читаются часто, но изменяются редко. Обычный мьютекс сериализует всех читателей без необходимости; `RwLock` позволяет всем конкурентным чтениям выполняться параллельно, сериализуя только при записи.

Реализация отдаёт предпочтение *писателям*: новые читатели блокируются, если писатель ожидает, предотвращая голодание писателей.

---

### Тип: `RwLock`

```nim
type RwLock* = object
```

Содержит условную переменную, мьютекс, счётчик читателей, счётчик ожидающих писателей и флаг активного писателя. Нельзя копировать или перемещать.

---

### `createRwLock`

```nim
proc createRwLock*(): RwLock
```

Создаёт и инициализирует блокировку чтения-записи. Единственный допустимый способ создать `RwLock`.

```nim
var rw = createRwLock()
var sharedData = 0
```

---

### `beginRead`

```nim
proc beginRead*(rw: var RwLock)
```

Захватывает разделяемую (читательскую) блокировку. Блокируется, если писатель в данный момент активен или ожидает. После захвата другие читатели также могут удерживать блокировку одновременно.

Всегда используйте в паре с `endRead`. Если между ними может возникнуть исключение, используйте шаблон `readWith`.

```nim
rw.beginRead()
let snapshot = sharedData  # безопасно читать совместно с другими читателями
rw.endRead()
```

---

### `endRead`

```nim
proc endRead*(rw: var RwLock)
```

Освобождает разделяемую (читательскую) блокировку. Если это был последний активный читатель, будит ожидающего писателя.

---

### `beginWrite`

```nim
proc beginWrite*(rw: var RwLock)
```

Захватывает исключительную (писательскую) блокировку. Блокируется до тех пор, пока все текущие читатели не завершат работу и активный писатель не освободит блокировку. После захвата вызывающий поток является единственным держателем.

Всегда используйте в паре с `endWrite`. Если возможно исключение, используйте `writeWith`.

```nim
rw.beginWrite()
sharedData += 1  # исключительный доступ — читателей и других писателей нет
rw.endWrite()
```

---

### `endWrite`

```nim
proc endWrite*(rw: var RwLock)
```

Освобождает исключительную (писательскую) блокировку и будит все ожидающие потоки (читателей и писателей), позволяя им конкурировать за блокировку.

---

### `readWith`

```nim
template readWith*(a: RwLock, body: untyped)
```

Шаблон-удобство: захватывает читательскую блокировку, выполняет `body` и освобождает блокировку в блоке `finally`, так что она всегда освобождается, даже если `body` бросает исключение. Эквивалентен `try/finally` вокруг `beginRead`/`endRead`, но лаконичнее и сложнее испортить.

```nim
readWith(rw):
  echo sharedData  # гарантированный читательский доступ; блокировка освобождается при выходе
```

---

### `writeWith`

```nim
template writeWith*(a: RwLock, body: untyped)
```

То же, что `readWith`, но для исключительной писательской блокировки.

```nim
writeWith rw:
  sharedData += 1  # исключительно; блокировка освобождается при выходе даже при исключении
```

---

## once

> **Модуль:** `once`  
> Требует: `--threads:on`

`Once` гарантирует, что блок кода выполняется **ровно один раз** среди всех потоков, сколько бы их ни вызывало его одновременно. Все остальные потоки, достигшие блока `once`, пока первый поток ещё выполняется, заблокируются и будут ждать. После завершения блока все потоки продолжают работу с гарантией, что каждый побочный эффект блока полностью виден.

Это канонический паттерн для ленивой, потокобезопасной инициализации одиночки (singleton).

**Поведение при исключении:** Если `body` выполняющегося потока бросает исключение, `Once` сбрасывается в начальное состояние. Следующий поток, вызвавший `once`, снова попытается выполнить тело. Семантика «пробуй, пока кто-нибудь не преуспеет» — именно то, что нужно для инициализации, которая может транзиторно завершиться неудачей.

---

### Тип: `Once`

```nim
type Once* = object
```

Содержит небольшой автомат состояний (`Unset`/`Pending`/`Complete`), мьютекс и условную переменную. Нельзя копировать или перемещать.

---

### `createOnce`

```nim
proc createOnce*(): Once
```

Создаёт и инициализирует объект `Once` в состоянии `Unset`. Единственный допустимый способ получить `Once`.

```nim
var o = createOnce()
```

---

### `once` (шаблон)

```nim
template once*(o: Once, body: untyped)
```

Выполняет `body` ровно один раз. Логика:

1. Если `Once` уже в состоянии `Complete`, немедленно пропускает тело и возвращается.
2. Если другой поток в данный момент выполняет тело (`Pending`), блокируется до его завершения, затем также пропускает и возвращается.
3. Если `Once` в состоянии `Unset`, этот поток выполняет тело:
   - При успехе: переходит в `Complete`, будит все ожидающие потоки.
   - При исключении: возвращается в `Unset`, будит все ожидающие потоки, повторно бросает исключение.

```nim
var o = createOnce()
var expensiveResource: ptr MyType = nil

proc getResource(): ptr MyType =
  once(o):
    expensiveResource = allocAndInitialise()
  result = expensiveResource
```

Сколько бы потоков ни вызывало `getResource()` одновременно, `allocAndInitialise()` будет вызвана ровно один раз.

---

## waitgroups

> **Модуль:** `waitgroups`  
> Требует: `--threads:on`

`WaitGroup` позволяет потоку-координатору ждать, пока динамический набор рабочих потоков не просигнализирует о завершении. В отличие от `Barrier` (который требует знать точное число потоков заранее), `WaitGroup` позволяет добавлять рабочих по одному и ждать всех их.

Схема работы:
1. Вызвать `enter(n)` — объявить, что вот-вот запустятся n рабочих.
2. Запустить рабочих. Каждый рабочий вызывает `leave()` по завершении.
3. Координатор вызывает `wait()` — блокируется до тех пор, пока внутренний счётчик не достигнет нуля.

---

### Тип: `WaitGroup`

```nim
type WaitGroup* = object
```

Содержит внутренний счётчик (количество незавершённых рабочих), мьютекс и условную переменную. Нельзя копировать или перемещать.

---

### `createWaitGroup`

```nim
proc createWaitGroup*(): WaitGroup
```

Создаёт `WaitGroup` с внутренним счётчиком, равным 0. Единственный допустимый способ создать `WaitGroup`.

```nim
var wg = createWaitGroup()
```

---

### `enter`

```nim
proc enter*(b: var WaitGroup; delta: Natural = 1)
```

Увеличивает счётчик незавершённых рабочих на `delta` (по умолчанию 1). Вызывайте `enter` **до** запуска соответствующих рабочих, чтобы `wait` не мог завершиться раньше времени, если рабочий успеет закончить до того, как координатор вызовет `wait`.

```nim
wg.enter(10)        # объявить, что запускаются 10 рабочих
for i in 0..<10:
  createThread(threads[i], worker, i)
```

---

### `leave`

```nim
proc leave*(b: var WaitGroup)
```

Уменьшает счётчик на 1. Должен вызываться каждым рабочим потоком при завершении задачи. Если счётчик достигает 0, любой поток, заблокированный в `wait`, немедленно пробуждается.

```nim
proc worker(i: int) =
  doWork(i)
  wg.leave()  # сигнализировать о завершении
```

---

### `wait` (WaitGroup)

```nim
proc wait*(b: var WaitGroup)
```

Блокирует вызывающий поток до тех пор, пока счётчик не достигнет 0, означая, что все рабочие, вызвавшие `enter`, также вызвали `leave`. Если счётчик уже равен 0 в момент вызова `wait`, функция немедленно возвращается.

```nim
wg.wait()             # блокироваться, пока все 10 рабочих не завершатся
for x in results:
  echo x              # безопасно читать — все рабочие завершили работу
```

---

## Как выбрать примитив

| Задача | Лучший выбор |
|---|---|
| Общий целочисленный счётчик между потоками | `Atomic[int]` |
| Генерация уникальных ID | `fetchAdd` |
| Подсчёт ссылок | `fetchSub` |
| Передача типизированных данных между потоками с передачей владения | `Chan[T]` |
| Ограничить одновременный доступ до N ресурсов | `Semaphore(N)` |
| Сигнал от одного потока другому (без общих данных) | `Semaphore(0)` |
| Синхронизировать N потоков между фиксированными фазами | `Barrier(N)` |
| Структура данных с частым чтением и редкой записью | `RwLock` |
| Потокобезопасный ленивый одиночка / одноразовая инициализация | `Once` |
| Ждать завершения динамической группы рабочих | `WaitGroup` |

### Ключевое поведение примитивов

| Примитив | Блокирует вызывающего? | Повторно используем? | Направление |
|---|---|---|---|
| `Atomic` | Никогда | Да | Нет — прямой доступ к памяти |
| `Chan.send` | Да (если полный) | Да | Производитель → Потребитель |
| `Chan.trySend` | Никогда | Да | Производитель → Потребитель |
| `Semaphore.wait` | Да (если счётчик = 0) | Да | Любой → Любой |
| `Barrier.wait` | Да (до прибытия всех) | Да (цикличный) | Все ↔ Все |
| `RwLock.beginRead` | Только если писатель активен/ждёт | Да | — |
| `RwLock.beginWrite` | Да (пока есть читатели/писатели) | Да | — |
| `Once.once` | Только пока тело выполняется | Нет (одноразовый) | — |
| `WaitGroup.wait` | Да (пока счётчик > 0) | Да (сбрасывается через `enter`) | Координатор ← Рабочие |
