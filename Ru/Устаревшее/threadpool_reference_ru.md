# Справочник модуля `threadpool` (Nim)

> Модуль `threadpool` реализует операторы `parallel` и `spawn` для параллельного выполнения задач через пул потоков.

> ⚠️ **Модуль устарел.** Вместо него рекомендуется использовать пакеты Nimble:  
> **[malebolgia](https://github.com/araq/malebolgia)**, **[taskpools](https://github.com/status-im/nim-taskpools)** или **[weave](https://github.com/mratsim/weave)**.

> ⚠️ **API нестабилен** и может измениться в будущих версиях Nim.

> ℹ️ Для компиляции требуется флаг `--threads:on`.

---

## Содержание

- [Константы](#константы)
- [Типы данных](#типы-данных)
- [Запуск задач](#запуск-задач)
- [FlowVar — ожидание результатов](#flowvar--ожидание-результатов)
- [Управление пулом потоков](#управление-пулом-потоков)
- [Синхронизация](#синхронизация)
- [Концепция работы](#концепция-работы)
- [Краткая шпаргалка](#краткая-шпаргалка)

---

## Константы

### `MaxThreadPoolSize`

Максимальный размер пула потоков. Значение по умолчанию — `256`. Может быть переопределено при компиляции через `-d:MaxThreadPoolSize=N`.

```nim
echo MaxThreadPoolSize   # 256
```

---

### `MaxDistinguishedThread`

Максимальное количество «выделенных» потоков (используемых `pinnedSpawn`). Значение по умолчанию — `32`. Переопределяется через `-d:MaxDistinguishedThread=N`.

```nim
echo MaxDistinguishedThread   # 32
```

---

## Типы данных

### `FlowVarBase`

Нетипизированный базовый класс для `FlowVar[T]`. Используется в функциях, работающих с любыми переменными потока данных независимо от типа результата (например, `blockUntilAny`, `isReady`).

---

### `FlowVar[T]`

**Переменная потока данных** — ссылочный объект, представляющий результат асинхронно выполняемой задачи. Возвращается оператором `spawn`, когда функция имеет возвращаемый тип.

Значение не доступно сразу — оно появляется по завершении задачи в фоновом потоке. Для получения значения используются оператор `^` или `awaitAndThen`.

```nim
proc double(x: int): int = x * 2

# spawn возвращает FlowVar[int]:
let fv: FlowVar[int] = spawn double(21)

# блокируем до готовности и читаем результат:
let result = ^fv
assert result == 42
```

---

### `ThreadId`

Идентификатор потока для `pinnedSpawn`. Диапазон: `0 .. MaxDistinguishedThread - 1`.

```nim
let tid: ThreadId = 0
pinnedSpawn tid, myProc(args)
```

---

## Запуск задач

### `spawn(call: sink typed)`

Всегда запускает вызов `call` в отдельном рабочем потоке из пула. Вызывающий поток **никогда** не выполняет задачу сам.

`call` должен быть вызовом процедуры `p(...)`, где `p` помечена как `gcsafe`. Возвращаемый тип `p` должен быть `void` или совместим с `FlowVar[T]`.

```nim
proc compute(n: int): int {.gcsafe.} =
  result = n * n

# Без результата:
proc printHello() {.gcsafe.} =
  echo "Hello from thread!"

spawn printHello()

# С результатом:
let fv = spawn compute(10)
echo ^fv   # 100

# Несколько задач:
var results: array[4, FlowVar[int]]
for i in 0..3:
  results[i] = spawn compute(i)
for i in 0..3:
  echo ^results[i]
```

---

### `pinnedSpawn(id: ThreadId; call: sink typed)`

Запускает задачу **всегда** в потоке с конкретным идентификатором `id`. Гарантирует, что задача будет выполнена именно в указанном «выделенном» потоке.

Полезно, когда задаче нужно работать с ресурсами, привязанными к конкретному потоку (например, OpenGL-контекст).

```nim
proc renderFrame(data: RenderData) {.gcsafe.} =
  # Должна выполняться в потоке с GPU-контекстом
  discard

let gpuThread: ThreadId = 0
pinnedSpawn gpuThread, renderFrame(myData)
```

---

### `spawnX(call)` — шаблон

Запускает задачу в новом потоке, **если** есть свободный CPU-ядро (т.е. `preferSpawn()` вернул `true`). В противном случае выполняет вызов **в вызывающем потоке**.

Осторожно: может привести к непредсказуемому времени выполнения в вызывающем потоке. Обычно предпочтительнее явный `spawn`.

```nim
spawnX myProc(arg)
# Эквивалент:
if preferSpawn(): spawn myProc(arg) else: myProc(arg)
```

---

### `parallel(body: untyped)`

Оператор параллельного выполнения блока. Тело `body` должно быть написано на специальном подмножестве языка (DSL для параллельных вычислений).

Подробнее см. [экспериментальное руководство Nim — parallel & spawn](https://nim-lang.org/docs/manual_experimental.html#parallel-amp-spawn).

```nim
parallel:
  for i in 0 ..< 4:
    spawn myProc(i)
```

---

## FlowVar — ожидание результатов

### `^[T](fv: FlowVar[T]): T`

Оператор разыменования FlowVar. **Блокирует** вызывающий поток до тех пор, пока результат не станет доступен, затем возвращает его.

```nim
proc fib(n: int): int {.gcsafe.} =
  if n <= 1: n else: fib(n-1) + fib(n-2)

let f = spawn fib(30)
# ... можно делать другую работу ...
let result = ^f   # блокируем здесь
echo result       # 832040
```

---

### `awaitAndThen[T](fv: FlowVar[T]; action: proc(x: T) {.closure.})`

Блокирует до готовности `fv`, затем передаёт результат в `action`. Может быть эффективнее `^`, поскольку позволяет избежать копирования `T` благодаря семантике передачи параметров Nim.

```nim
let fv = spawn computeData(42)
fv.awaitAndThen do (x: int):
  echo "Результат: ", x
  process(x)
```

---

### `unsafeRead*[T](fv: FlowVar[ref T]): ptr T`

Блокирует до готовности `fv` и возвращает **указатель** на значение типа `ref T`. Операция небезопасна — вызывающий код берёт на себя ответственность за время жизни объекта.

```nim
type Data = ref object
  value: int

proc makeData(n: int): Data {.gcsafe.} =
  Data(value: n * 2)

let fv = spawn makeData(10)
let p = unsafeRead(fv)
echo p.value   # 20
```

---

### `blockUntil(fv: var FlowVarBaseObj)`

Блокирует вызывающий поток до тех пор, пока значение `fv` не станет доступным. Обычно вызывать явно не нужно — `^` и `awaitAndThen` делают это автоматически.

```nim
var fvBase: FlowVarBase = spawn myProc()
blockUntil(fvBase[])
```

---

### `blockUntilAny(flowVars: openArray[FlowVarBase]): int`

Ожидает **любого** из `flowVars`. Возвращает **индекс** первого FlowVar, для которого пришёл результат. Если ни один не может быть ожидаем — возвращает `-1`.

> ⚠️ Каждый FlowVar поддерживает только **один** одновременный вызов `blockUntilAny`. Приводит к недетерминированному поведению — используйте с осторожностью.

```nim
let f1 = spawn slowTask(1)
let f2 = spawn slowTask(2)
let f3 = spawn slowTask(3)

# Ждём первого завершившегося:
let idx = blockUntilAny([FlowVarBase(f1), FlowVarBase(f2), FlowVarBase(f3)])
echo "Первым завершился индекс: ", idx
```

---

### `isReady(fv: FlowVarBase): bool`

Проверяет, доступен ли результат **без блокировки**. Если возвращает `true`, вызов `^fv` не заблокирует поток.

```nim
let fv = spawn longComputation()

# Неблокирующий опрос:
while not isReady(fv):
  echo "Ещё не готово, делаем другую работу..."
  doOtherWork()

echo "Результат: ", ^fv
```

---

## Управление пулом потоков

### `setMinPoolSize(size: range[1..MaxThreadPoolSize])`

Устанавливает **минимальное** число потоков в пуле. Значение по умолчанию — `4`. Пул никогда не уменьшится ниже этого значения.

```nim
setMinPoolSize(2)
```

---

### `setMaxPoolSize(size: range[1..MaxThreadPoolSize])`

Устанавливает **максимальное** число потоков в пуле. По умолчанию равно `MaxThreadPoolSize` (256). Если текущий размер пула превышает новый максимум, лишние потоки помечаются для завершения.

```nim
setMaxPoolSize(8)   # ограничить пул 8 потоками
```

---

### `preferSpawn(): bool`

Быстро проверяет, целесообразен ли `spawn` в данный момент (есть ли свободный рабочий поток). Возвращает `true`, если `spawn` может быть полезен. Используется внутри шаблона `spawnX`.

```nim
if preferSpawn():
  spawn myTask()
else:
  myTask()   # выполнить синхронно
```

---

## Синхронизация

### `sync()`

Простой барьер: блокирует вызывающий поток до тех пор, пока **все** задачи, запущенные через `spawn`, не завершатся. Проверяет готовность всех рабочих потоков пула.

> Если требуется более тонкое управление синхронизацией, используйте явные барьеры из модуля `locks`.

```nim
for i in 0 ..< 10:
  spawn worker(i)

sync()   # ждём завершения всех 10 задач
echo "Все задачи выполнены"
```

---

## Концепция работы

### Жизненный цикл задачи

```
Вызывающий поток          Пул потоков
      │                       │
      │  spawn myProc(args)   │
      ├──────────────────────►│  Рабочий поток берёт задачу
      │                       │  и выполняет myProc(args)
      │  let fv = spawn ...   │
      │                       │  результат записывается в FlowVar
      │  let r = ^fv   ───────┼──► (блокируется если ещё не готово)
      │◄──────────────────────┤  сигнал: значение готово
      │  r == результат       │
```

### Автоматическое масштабирование пула

Пул потоков динамически адаптирует свой размер:
- Запускается с числом потоков, равным числу ядер процессора.
- При нехватке потоков автоматически добавляет новые (до `maxPoolSize`).
- При низкой нагрузке завершает лишние потоки (до `minPoolSize`).

### Требования к функциям для `spawn`

Функция, передаваемая в `spawn`, должна:
- Быть помечена `{.gcsafe.}` (не захватывать глобальные изменяемые данные без синхронизации).
- Иметь возвращаемый тип `void` или совместимый с `FlowVar[T]`.

```nim
# Правильно:
proc safeWorker(x: int): string {.gcsafe.} =
  $x & " processed"

# Неправильно — GC-unsafe функция вызовет ошибку компилятора:
var globalData: seq[int]
proc unsafeWorker(x: int) =   # не gcsafe
  globalData.add(x)
```

---

## Краткая шпаргалка

### Операции

| Операция | Описание |
|---|---|
| `spawn myProc(args)` | Запустить задачу в пуле, всегда в фоновом потоке |
| `pinnedSpawn id, myProc(args)` | Запустить задачу в конкретном выделенном потоке |
| `spawnX myProc(args)` | Запустить в потоке если есть свободный, иначе — синхронно |
| `parallel: ...` | Параллельный блок (DSL) |
| `^fv` | Заблокировать и получить результат из FlowVar |
| `fv.awaitAndThen(action)` | Заблокировать и передать результат в замыкание |
| `unsafeRead(fv)` | Получить указатель на результат `FlowVar[ref T]` |
| `blockUntil(fv)` | Явно ждать готовности FlowVarBase |
| `blockUntilAny(fvs)` | Ждать первого готового из массива FlowVar |
| `isReady(fv)` | Проверить готовность без блокировки |
| `sync()` | Барьер: ждать завершения всех spawn-задач |
| `setMinPoolSize(n)` | Задать минимальный размер пула (по умолчанию 4) |
| `setMaxPoolSize(n)` | Задать максимальный размер пула (по умолчанию 256) |
| `preferSpawn()` | Проверить наличие свободного потока |

### Типичный паттерн: параллельный map

```nim
import std/threadpool

proc processItem(x: int): int {.gcsafe.} =
  x * x + 1

const N = 8
var futures: array[N, FlowVar[int]]

# Запускаем все задачи:
for i in 0 ..< N:
  futures[i] = spawn processItem(i)

# Собираем результаты:
var results: array[N, int]
for i in 0 ..< N:
  results[i] = ^futures[i]

echo results   # [1, 2, 5, 10, 17, 26, 37, 50]
```

### Примечания

- Модуль **устарел**; для новых проектов используйте `malebolgia`, `taskpools` или `weave`.
- Необходим флаг компилятора `--threads:on`.
- Начальный размер пула равен числу логических ядер процессора.
- `FlowVar` уничтожается (деструктор `=destroy`) при выходе из области видимости и автоматически освобождает связанные ресурсы.
- `blockUntilAny` приводит к **недетерминированному поведению** и должен использоваться с осторожностью.
- Размер пула регулируется параметром компиляции `threadpoolWaitMs` (по умолчанию 100 мс).
