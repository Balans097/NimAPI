# Справочник модуля `hashes`

> **Стандартная библиотека Nim — `std/hashes`**
> Эффективное вычисление хеш-значений для встроенных и пользовательских типов Nim.
> Основа всех структур данных на хеш-таблицах в стандартной библиотеке.

---

## Содержание

1. [Обзор и принцип работы](#обзор-и-принцип-работы)
2. [Типы](#типы)
   - [Hash](#hash)
3. [Операторы-строительные блоки](#операторы-строительные-блоки)
   - [!& (смешивание)](#-смешивание)
   - [!$ (завершение)](#-завершение)
4. [Специализированные хеш-функции](#специализированные-хеш-функции)
   - [hashWangYi1](#hashwangyi1)
   - [hashData](#hashdata)
   - [hashIdentity](#hashidentity)
5. [Перегрузки `hash` для стандартных типов](#перегрузки-hash-для-стандартных-типов)
   - [hash — целые числа и перечисления](#hash--целые-числа-и-перечисления)
   - [hash — float](#hash--float)
   - [hash — pointer](#hash--pointer)
   - [hash — ptr\[T\]](#hash--ptrt)
   - [hash — ref\[T\]](#hash--reft)
   - [hash — string (полная строка)](#hash--string-полная-строка)
   - [hash — string (срез)](#hash--string-срез)
   - [hash — cstring](#hash--cstring)
   - [hash — tuple, object, proc, closure](#hash--tuple-object-proc-closure)
   - [hash — openArray\[A\] (полный)](#hash--openarrayt-полный)
   - [hash — openArray\[A\] (срез)](#hash--openarrayt-срез)
   - [hash — set\[A\]](#hash--seta)
6. [Хеширование без учёта регистра и стиля](#хеширование-без-учёта-регистра-и-стиля)
   - [hashIgnoreCase (полная строка)](#hashignorecase--полная-строка)
   - [hashIgnoreCase (срез)](#hashignorecase--срез)
   - [hashIgnoreStyle (полная строка)](#hashignorestyle--полная-строка)
   - [hashIgnoreStyle (срез)](#hashignorestyle--срез)
7. [Реализация `hash` для пользовательских типов](#реализация-hash-для-пользовательских-типов)
8. [Важные правила и подводные камни](#важные-правила-и-подводные-камни)
9. [Полные рабочие примеры](#полные-рабочие-примеры)

---

## Обзор и принцип работы

**Хеш-функция** принимает значение любого типа и возвращает единственное целое число (`Hash`) — уникальный компактный «отпечаток» этого значения. Хеш-таблицы (такие как `Table` и `HashSet` в Nim) используют эти отпечатки, чтобы находить хранящиеся значения за O(1) в среднем, не обходя всю коллекцию.

Модуль `hashes` предоставляет:

1. **Готовые процедуры `hash`** для всех встроенных типов Nim — целых чисел, вещественных, строк, массивов, последовательностей, кортежей, объектов и т.д. Для стандартных типов ничего делать не нужно.
2. **Два строительных блока** (`!&` и `!$`) для компоновки хешей при написании `hash`-процедуры для собственного типа.
3. **Варианты хеширования строк**, нечувствительные к регистру или стилю именования.

```
Ваше значение
      │
      ▼
  hash(x)         ← диспетчеризация к нужной перегрузке
      │
      ▼
   Hash            ← обычный int; помещается в регистр; используется как индекс таблицы
```

Два строительных блока реализуют конкретный алгоритм: вы подмешиваете каждый компонент данных в накопитель с помощью `!&`, а затем «лавинообразно» распространяете накопленные биты с помощью `!$`, получая хорошо распределённое итоговое значение.

```
h = 0
h = h !& hash(поле1)    ← подмешиваем
h = h !& hash(поле2)    ← подмешиваем
result = !$h             ← завершаем (лавинный эффект)
```

---

## Типы

### `Hash`

```nim
type Hash* = int
```

Тип всех хеш-значений. Это просто псевдоним для `int` — знакового целого, разрядность которого совпадает с разрядностью слова платформы (32 бита на 32-битных системах, 64 бита на 64-битных).

Из этого типа вытекают два фундаментальных ограничения:

1. **Хеш-таблицы должны иметь размер, равный степени двойки.** Это позволяет рантайму использовать быструю побитовую операцию `and` для отображения `Hash` на индекс слота вместо медленной операции `mod`.
2. **Контракт хеш-равенства должен соблюдаться:** если `a == b`, то `hash(a) == hash(b)`. Обратное не требуется — *коллизии* (два неравных значения с одинаковым хешем) допустимы и обрабатываются таблицей.

Вам никогда не нужно беспокоиться об арифметике целых чисел: строительные блоки берут это на себя.

---

## Операторы-строительные блоки

Эти два оператора — всё, что вам нужно при написании `hash`-процедур для собственных типов. Всё остальное в модуле использует их внутри себя.

### `!&` (смешивание)

```nim
proc `!&`*(h: Hash, val: int): Hash {.inline.}
```

**Что делает:** Подмешивает целое число `val` в текущий накопитель `h` и возвращает новый накопитель. Операция представляет собой тщательно подобранную комбинацию сложения, сдвигов и XOR, спроектированную для равномерного распределения битов и минимизации коллизий.

Это оператор, а не именованная процедура, поэтому он используется в инфиксной записи: `h = h !& someValue`.

**Когда использовать:** Каждый раз, когда нужно включить одну порцию данных (одно поле, один элемент) в строящийся хеш. Всегда используйте в паре с `!$` в конце.

```nim
var h: Hash = 0
h = h !& 42           # подмешиваем целое напрямую
h = h !& hash("hi")   # подмешиваем хеш другого значения
result = !$h
```

```nim
# Типичный шаблон при итерации по частям значения:
var h: Hash = 0
for item in myCollection:
  h = h !& hash(item)
result = !$h
```

---

### `!$` (завершение)

```nim
proc `!$`*(h: Hash): Hash {.inline.}
```

**Что делает:** Завершает вычисление хеша и возвращает итоговое значение. Применяет финальный «лавинный» шаг — дополнительные сдвиги и XOR — чтобы небольшие различия в накопленном значении давали сильно отличающиеся выходные биты. Без этого шага накопленный хеш имел бы плохое распределение для коротких или похожих входных данных.

Это унарный префиксный оператор: `result = !$h`.

**Когда использовать:** Ровно один раз, в самом конце вашей `hash`-процедуры, после того как все поля были подмешаны с `!&`. Никогда не вызывайте его в середине накопления.

```nim
# Правильно: один вызов !$ в конце
var h: Hash = 0
h = h !& hash(x.name)
h = h !& hash(x.age)
result = !$h          # ← завершаем здесь

# Неправильно: НЕ вызывайте !$ посередине, а затем продолжайте смешивать
var h: Hash = 0
h = h !& hash(x.name)
h = !$h               # ← ошибка! преждевременное завершение
h = h !& hash(x.age)  # последующее смешивание недопустимо
result = !$h
```

---

## Специализированные хеш-функции

### `hashWangYi1`

```nim
proc hashWangYi1*(x: int64 | uint64 | Hash): Hash {.inline.}
```

**Что делает:** Реализует алгоритм Wang Yi `hash_v1` для 64-битных целых чисел. Это высококачественная однопроходная хеш-функция, прошедшая все тесты на перемешивание в наборе SMHasher. Именно этот алгоритм используется внутри `hash(T: Ordinal)`, когда флаг компиляции `nimIntHash1` не установлен (поведение по умолчанию).

Вы бы обращались к этой функции напрямую, если хотите хешировать 64-битное целое с помощью именно этого алгоритма — например, при построении хеша для пользовательского типа, содержащего поля `int64`, и вам нужен последовательный, хорошо распределённый результат.

Подсказка из исходника: вы можете безопасно сужать другие целочисленные типы до 64 бит перед передачей: `proc hash(x: int16): Hash = hashWangYi1(Hash(x))`.

**Замечание о платформах:** На JavaScript-платформах без поддержки `BigInt` результат сводится к 32-битному значению.

```nim
import std/hashes

echo hashWangYi1(0'i64)       # хорошо распределённый хеш нуля
echo hashWangYi1(1'i64)       # сильно отличается, хотя отличие всего в 1
echo hashWangYi1(high(int64)) # корректно обрабатывает экстремальные значения
```

---

### `hashData`

```nim
proc hashData*(data: pointer, size: int): Hash
```

**Что делает:** Вычисляет хеш `size` сырых байт, начиная с адреса памяти `data`. Это низкоуровневый строительный блок для ситуаций, когда у вас есть нетипизированные двоичные данные — например, указатель на структуру C, необработанный буфер или любой регион памяти, который не отображается удобно на тип Nim.

Функция читает каждый байт и подмешивает его в накопитель через `!&`, а затем завершает через `!$`. Это намеренно простая и переносимая реализация — не такая быстрая, как FarmHash или MurmurHash для больших данных, но корректная и без зависимостей.

**Когда использовать:** При работе с сырой памятью (`pointer`, `ptr UncheckedArray[byte]`, данные из FFI). Для обычных массивов или последовательностей байт Nim предпочтительнее использовать типизированную перегрузку `hash(openArray[byte])`.

```nim
import std/hashes

var buffer = [0x48'u8, 0x65, 0x6c, 0x6c, 0x6f]  # "Hello" в байтах
let h = hashData(addr buffer[0], buffer.len)
echo h  # хеш-значение для этих 5 байт
```

---

### `hashIdentity`

```nim
proc hashIdentity*[T: Ordinal | enum](x: T): Hash {.inline, since: (1, 3).}
```

**Что делает:** Возвращает `ord(x)`, приведённое непосредственно к `Hash`, — значение является собственным хешем. Нет ни перемешивания, ни лавинного шага. Это называется «тождественным хешем», потому что `hashIdentity(x) == ord(x)` для любого `x`.

**Когда использовать:** В критичных по производительности сценариях, где ключи хеш-таблицы уже равномерно распределены (например, уникальные ID, плотно упакованные значения перечислений или внешне сгенерированные случайные целые числа). Тождественный хеш позволяет избежать накладных расходов на перемешивание и может ускорить поиск. Однако он работает *плохо*, если ключи распределены неравномерно — например, последовательные маленькие числа `0, 1, 2, 3` будут скапливаться в одних и тех же ячейках таблицы.

```nim
import std/hashes

type Status = enum
  Pending, Running, Done, Failed

echo hashIdentity(Pending)  # 0
echo hashIdentity(Running)  # 1
echo hashIdentity(Done)     # 2

# Для целых чисел:
echo hashIdentity(42)   # 42
echo hashIdentity(100)  # 100
```

---

## Перегрузки `hash` для стандартных типов

### `hash` — целые числа и перечисления

```nim
proc hash*[T: Ordinal | enum](x: T): Hash {.inline.}
```

**Что делает:** Хеширует любой целочисленный тип (`int`, `int8`, `int16`, `int32`, `int64`, `uint` и т.д.) или значение перечисления `enum`. Внутри по умолчанию вызывает `hashWangYi1` (или откатывается к тождественному хешу при компиляции с `-d:nimIntHash1`).

Хеш вычисляется по `ord`-значению `x`, поэтому перечисления хешируются по их порядковому номеру, а не по имени.

```nim
import std/hashes

echo hash(0)          # хорошо распределённое значение, не 0
echo hash(42)
echo hash(-1)
echo hash(high(int))

type Color = enum Red, Green, Blue
echo hash(Red)    # хеш от 0
echo hash(Green)  # хеш от 1
echo hash(Blue)   # хеш от 2
```

---

### `hash` — float

```nim
proc hash*(x: float): Hash {.inline.}
```

**Что делает:** Хеширует число с плавающей запятой, переинтерпретируя его битовое представление как целое и применяя `hashWangYi1`. Перед хешированием вычисляется `x + 0.0` для нормализации денормализованных значений (чтобы `+0.0` и `-0.0` давали одинаковый хеш).

```nim
import std/hashes

echo hash(3.14)
echo hash(0.0)
echo hash(-0.0)  # то же, что hash(0.0) — нормализация
echo hash(float(1))  # то же, что hash(1.0)
```

---

### `hash` — pointer

```nim
proc hash*(x: pointer): Hash {.inline.}
```

**Что делает:** Хеширует значение сырого указателя `pointer` — то есть сам адрес памяти, а не то, на что он указывает. Два указателя на одно место в памяти дают одинаковый хеш; два указателя на разные места (даже с одинаковым значением по этому адресу) дают разные хеши.

На JavaScript-платформах, где у указателей нет числового адреса, при первом хешировании объекту присваивается инкрементный идентификатор, который затем переиспользуется.

```nim
import std/hashes

var a, b: int = 0
let pa = addr a
let pb = addr b
echo hash(pa) == hash(pa)  # true — один и тот же адрес
echo hash(pa) == hash(pb)  # false — разные адреса
```

---

### `hash` — ptr\[T\]

```nim
proc hash*[T](x: ptr[T]): Hash {.inline.}
```

**Что делает:** Хеширует типизированный указатель `ptr[T]` по его адресу. Это тонкая обёртка: типизированный указатель приводится к нетипизированному `pointer` и передаётся в `hash(pointer)`. Хеш отражает *место*, на которое указывает указатель, а не *содержимое* по этому адресу.

```nim
import std/hashes

var arr: array[10, uint8]
# У соседних элементов разные адреса → разные хеши
assert arr[0].addr.hash != arr[1].addr.hash
# Типизированный и нетипизированный указатели на одно место хешируются одинаково
assert cast[pointer](arr[0].addr).hash == arr[0].addr.hash
```

---

### `hash` — ref\[T\]

```nim
proc hash*[T](x: ref[T]): Hash {.inline.}
```

**Что делает:** Хеширует `ref T` по адресу объекта на куче (то есть по идентичности ссылки, а не по значению). Две переменные `ref`, указывающие на один объект, дают одинаковый хеш; две переменные `ref`, указывающие на разные объекты с идентичными полями, дают *разные* хеши.

> **Важно:** Эта процедура доступна только при компиляции с флагом `-d:nimPreviewHashRef`. Ожидается, что в будущих версиях Nim это станет поведением по умолчанию. Без флага попытка хешировать `ref` вызовет ошибку компиляции.

```nim
# Компилировать так: nim c -d:nimPreviewHashRef myfile.nim
import std/hashes

type Node = ref object
  value: int

let a = Node(value: 3)
let b = Node(value: 3)  # то же содержимое, но разный объект
let c = a               # тот же объект, что и a

assert hash(a) == hash(c)  # true: та же ссылка (тот же адрес)
assert hash(a) != hash(b)  # true: разные ссылки (разные адреса)

# Чтобы хешировать по содержимому, определите собственный hash:
proc hash(n: Node): Hash = hash(n.value)
assert hash(a) == hash(b)  # теперь true: одинаковое содержимое
```

---

### `hash` — string (полная строка)

```nim
proc hash*(x: string): Hash
```

**Что делает:** Хеширует строку целиком. На нативных платформах используется алгоритм **FarmHash** (по умолчанию — быстрый, высококачественный, прошёл SMHasher), на JavaScript и при компиляции с `-d:nimStringHash2` — **MurmurHash3**. Оба алгоритма чувствительны к регистру: `"Hello"` и `"hello"` дают разные хеши.

```nim
import std/hashes

echo hash("abracadabra")
assert hash("Hello") != hash("hello")   # чувствительно к регистру
assert hash("") != hash(" ")            # даже пробел важен
assert hash("abc") == hash("abc")       # детерминировано в пределах одного запуска
```

---

### `hash` — string (срез)

```nim
proc hash*(sBuf: string, sPos, ePos: int): Hash
```

**Что делает:** Хеширует *подстроку* `sBuf` от индекса `sPos` до `ePos` **включительно** с обеих сторон. Позволяет избежать выделения памяти под новую строку. `hash(s, 0, s.high)` полностью эквивалентно `hash(s)`.

```nim
import std/hashes

let s = "abracadabra"
# "abra" встречается на позициях 0..3 и 7..10
assert hash(s, 0, 3) == hash(s, 7, 10)  # одинаковая подстрока → одинаковый хеш
assert hash(s, 0, 3) != hash(s, 0, 4)   # разная длина → разный хеш
```

---

### `hash` — cstring

```nim
proc hash*(x: cstring): Hash
```

**Что делает:** Хеширует null-терминированную C-строку. Результат идентичен хешу аналогичной Nim-строки — для целей хеширования они взаимозаменяемы. Полезно при взаимодействии с C-библиотеками или работе с `cstring`-значениями напрямую.

```nim
import std/hashes

assert hash(cstring"abracadabra") == hash("abracadabra")
assert hash(cstring"Hello") != hash(cstring"hello")
```

---

### `hash` — tuple, object, proc, closure

```nim
proc hash*[T: tuple | object | proc | iterator {.closure.}](x: T): Hash
```

**Что делает:** Обобщённый хеш для составных типов:

- **Кортежи и объекты**: проходит по всем полям через `fields()` и смешивает их индивидуальные хеши с помощью `!&` / `!$`. Для этого у каждого типа поля должна быть определена процедура `hash`. Вы можете переопределить это поведение для любого конкретного типа объекта, написав собственный `hash` для него.
- **Обычные процедуры** (не замыкания): хешируется адрес функции в виде указателя. Два значения proc, указывающие на одну функцию, имеют одинаковый хеш.
- **Замыкания**: хешируется пара `(rawProc, rawEnv)` — указатель на функцию и указатель на окружение, — поэтому два замыкания над разными окружениями хешируются по-разному, даже если используют одно тело функции.

```nim
import std/hashes

# Хеширование кортежей — автоматически, поле за полем
let t1 = (1, "hello")
let t2 = (1, "world")
assert hash(t1) != hash(t2)

# Хеширование объектов — автоматически
type Point = object
  x, y: int
assert hash(Point(x: 1, y: 2)) != hash(Point(x: 1, y: 3))

# Переопределение: хешировать только по x, игнорировать y
type WeirdPoint = object
  x, y: int
proc hash(p: WeirdPoint): Hash = hash(p.x)
assert hash(WeirdPoint(x: 5, y: 10)) == hash(WeirdPoint(x: 5, y: 99))

# Хеширование процедур
proc myFunc() = discard
let f1 = myFunc
let f2 = myFunc
assert hash(f1) == hash(f2)  # та же функция
```

---

### `hash` — openArray\[A\] (полный)

```nim
proc hash*[A](x: openArray[A]): Hash
```

**Что делает:** Хеширует массив или последовательность целиком. Тип элемента `A` должен иметь определённую процедуру `hash`. Для элементов типа `byte` и `char` FarmHash (или MurmurHash на JS) применяется непосредственно к байтам — это очень быстро. Для других типов элементов каждый хешируется отдельно, результаты смешиваются.

Работает прозрачно с `array`, `seq` и параметрами `openArray`.

```nim
import std/hashes

let a = [1, 2, 3]
let b = [1, 2, 3]
let c = [1, 2, 4]

assert hash(a) == hash(b)   # одинаковые элементы → одинаковый хеш
assert hash(a) != hash(c)   # разные элементы

# Работает и с последовательностями
let s1 = @["x", "y"]
let s2 = @["x", "z"]
assert hash(s1) != hash(s2)

# Массивы байт используют быстрый путь
let bytes = [0x48'u8, 0x65, 0x6c, 0x6c, 0x6f]
echo hash(bytes)
```

---

### `hash` — openArray\[A\] (срез)

```nim
proc hash*[A](aBuf: openArray[A], sPos, ePos: int): Hash
```

**Что делает:** Хеширует непрерывный подинтервал массива или последовательности от индекса `sPos` до `ePos` включительно. Позволяет обойтись без создания временного среза. `hash(a, 0, a.high)` эквивалентно `hash(a)`.

```nim
import std/hashes

let a = [1, 2, 5, 1, 2, 6]
# Элементы [1, 2] встречаются на позициях 0..1 и 3..4
assert hash(a, 0, 1) == hash(a, 3, 4)
assert hash(a, 0, 2) != hash(a, 3, 5)  # [1,2,5] != [1,2,6]
```

---

### `hash` — set\[A\]

```nim
proc hash*[A](x: set[A]): Hash
```

**Что делает:** Хеширует множество Nim (`set` — битовое множество малых `Ordinal`-значений). Перебирает все присутствующие элементы, хеширует каждый отдельно и смешивает результаты. Тип элемента `A` должен быть совместим с `set` в Nim (как правило, `enum`, `char` или небольшие целые числа).

```nim
import std/hashes

let s1 = {'a', 'b', 'c'}
let s2 = {'a', 'b', 'c'}
let s3 = {'a', 'b', 'd'}

assert hash(s1) == hash(s2)
assert hash(s1) != hash(s3)
```

---

## Хеширование без учёта регистра и стиля

Эти специализированные процедуры хешируют строки, нормализуя определённые текстовые различия. Они используют строительные блоки `!&`/`!$` (а не FarmHash или MurmurHash), поэтому их результат **отличается** от стандартного `hash(string)` даже для идентичных входных данных — они не являются взаимозаменяемыми заменами.

> **Примечание:** Все четыре процедуры используют тот же алгоритм смешивания, что и строительные блоки `!&`/`!$`, а не более быстрый FarmHash/MurmurHash. Это намеренно: проход нормализации уже касается каждого символа по отдельности и является узким местом производительности.

### `hashIgnoreCase` — полная строка

```nim
proc hashIgnoreCase*(x: string): Hash
```

**Что делает:** Хеширует строку, предварительно приведя все ASCII-заглавные буквы к строчным. Все остальные символы (включая подчёркивания, цифры и не-ASCII байты) хешируются как есть.

```nim
import std/hashes

assert hashIgnoreCase("ABRAcaDABRA") == hashIgnoreCase("abracadabra")
assert hashIgnoreCase("Hello!")      == hashIgnoreCase("HELLO!")
assert hashIgnoreCase("abc") != hash("abc")  # разные алгоритмы!
```

**Практический случай:** Построение нечувствительной к регистру хеш-таблицы для идентификаторов, HTTP-заголовков или любой области, где `"Content-Type"` и `"content-type"` должны считаться одним и тем же ключом.

---

### `hashIgnoreCase` — срез

```nim
proc hashIgnoreCase*(sBuf: string, sPos, ePos: int): Hash
```

**Что делает:** То же, что `hashIgnoreCase(string)`, но работает с подстрокой `sBuf` от `sPos` до `ePos` включительно. Не требует выделения памяти под новую строку.

```nim
import std/hashes

let s = "ABracadabRA"
assert hashIgnoreCase(s, 0, 3) == hashIgnoreCase(s, 7, 10)  # "ABra" == "abRA"
```

---

### `hashIgnoreStyle` — полная строка

```nim
proc hashIgnoreStyle*(x: string): Hash
```

**Что делает:** Хеширует строку, игнорируя как регистр, так и символы подчёркивания. Это отражает правила сравнения идентификаторов самого Nim, где `myVariable`, `my_variable` и `MyVariable` считаются одним и тем же идентификатором. Конкретно: все символы `A-Z` преобразуются в строчные эквиваленты, а все `_` просто пропускаются.

```nim
import std/hashes

assert hashIgnoreStyle("aBr_aCa_dAB_ra") == hashIgnoreStyle("abracadabra")
assert hashIgnoreStyle("my_func")        == hashIgnoreStyle("myFunc")
assert hashIgnoreStyle("MY_CONSTANT")    == hashIgnoreStyle("myConstant")

# Всё же отличается от hash(string)
assert hashIgnoreStyle("abcdefghi") != hash("abcdefghi")
```

**Практический случай:** Построение таблиц символов, разрешение импортов или любая система, которая должна следовать нечувствительному к стилю сравнению идентификаторов Nim.

---

### `hashIgnoreStyle` — срез

```nim
proc hashIgnoreStyle*(sBuf: string, sPos, ePos: int): Hash
```

**Что делает:** То же, что `hashIgnoreStyle(string)`, но работает с подстрокой. `hashIgnoreStyle(myBuf, 0, myBuf.high)` эквивалентно `hashIgnoreStyle(myBuf)`.

```nim
import std/hashes

let s = "ABracada_b_r_a"
assert hashIgnoreStyle(s, 0, 3) == hashIgnoreStyle(s, 7, s.high)
```

---

## Реализация `hash` для пользовательских типов

Когда вы определяете новый тип, который планируете использовать как ключ в `Table` или `HashSet`, необходимо реализовать для него процедуру `hash`. Существует несколько шаблонов.

### Шаблон 1: Смешивание хешей полей напрямую

Наиболее распространённый и идиоматичный подход. Хешируем каждое поле, смешиваем с `!&`, завершаем через `!$`.

```nim
import std/hashes

type Person = object
  name: string
  age:  int

proc hash(p: Person): Hash =
  var h: Hash = 0
  h = h !& hash(p.name)
  h = h !& hash(p.age)
  result = !$h
```

### Шаблон 2: Делегирование кортежу

Краткая альтернатива, использующая встроенный хеш кортежей:

```nim
import std/hashes

type Color = object
  r, g, b: uint8

proc hash(c: Color): Hash =
  hash((c.r, c.g, c.b))  # хешируем эквивалентный кортеж
```

### Шаблон 3: Итерация с пользовательским итератором

Для типов с переменной длиной или вычисляемыми компонентами:

```nim
import std/hashes

type TagSet = object
  tags:     seq[string]
  priority: int

iterator items(t: TagSet): Hash =
  yield hash(t.priority)
  for tag in t.tags:
    yield hash(tag)

proc hash(t: TagSet): Hash =
  var h: Hash = 0
  for atom in t:
    h = h !& atom
  result = !$h
```

### Обязательный контракт

Всякий раз, когда вы определяете `hash` для типа, вы **обязаны** гарантировать:

> Если `a == b`, то `hash(a) == hash(b)`.

Это значит: если вы также определяете пользовательский `==` для своего типа, ваш `hash` должен быть с ним согласован — равные объекты должны иметь равные хеши. Нарушение этого контракта вызывает молчаливые, трудно отлаживаемые сбои в хеш-таблицах.

---

## Важные правила и подводные камни

**Правило 1 — Всегда завершайте через `!$`.**
Забытый `!$` даёт плохо распределённый хеш. Каждая написанная вами `hash`-процедура должна заканчиваться строкой `result = !$h`.

**Правило 2 — Никогда не вызывайте `!$` посередине накопления.**
После вызова `!$` значение считается завершённым. Последующее подмешивание данных уничтожает гарантии качества. `!$` должен быть самым последним шагом.

**Правило 3 — `hashIgnoreCase` / `hashIgnoreStyle` несовместимы с `hash(string)`.**
Эти функции используют другой алгоритм. Не смешивайте их в одной и той же хеш-таблице. Если ваша таблица использует ключи через `hashIgnoreCase`, все обращения тоже должны использовать `hashIgnoreCase`.

**Правило 4 — `hash(ref T)` требует `-d:nimPreviewHashRef`.**
Без этого флага попытка хешировать значение `ref` не скомпилируется. Флаг меняет семантику: `ref` хешируется по адресу (идентичности), а не по содержимому.

**Правило 5 — Хеши не стабильны между запусками и версиями.**
Значения `Hash` в Nim не гарантированно совпадают между разными запусками программы, разными версиями Nim или разными платформами. Не сериализуйте значения `Hash` на диск и не передавайте их по сети.

**Правило 6 — `hash(pointer)` / `hash(ref)` хешируют адрес, а не содержимое.**
Если вы хотите использовать `ref` как ключ хеш-таблицы по *идентичности* объекта (а не по его полям), используйте встроенный хеш (с флагом предпросмотра). Если нужно хеширование по содержимому — определите пользовательский `hash`.

---

## Полные рабочие примеры

### Пример 1: Пользовательский хеш для составного типа

```nim
import std/[hashes, tables]

type
  Point = object
    x, y: float

proc hash(p: Point): Hash =
  var h: Hash = 0
  h = h !& hash(p.x)
  h = h !& hash(p.y)
  result = !$h

proc `==`(a, b: Point): bool =
  a.x == b.x and a.y == b.y

# Теперь Point можно использовать как ключ Table
var distances: Table[Point, float]
distances[Point(x: 0.0, y: 0.0)] = 0.0
distances[Point(x: 3.0, y: 4.0)] = 5.0

echo distances[Point(x: 3.0, y: 4.0)]  # 5.0
```

---

### Пример 2: Таблица строк без учёта регистра

```nim
import std/[hashes, tables, strutils]

# Оборачиваем ключ, чтобы определить для него hash и ==
type CIString = distinct string

proc hash(s: CIString): Hash =
  hashIgnoreCase(string(s))

proc `==`(a, b: CIString): bool =
  cmpIgnoreCase(string(a), string(b)) == 0

var headers: Table[CIString, string]
headers[CIString("Content-Type")]  = "application/json"
headers[CIString("Authorization")] = "Bearer xyz"

# Поиск нечувствителен к регистру:
echo headers[CIString("content-type")]   # "application/json"
echo headers[CIString("AUTHORIZATION")]  # "Bearer xyz"
```

---

### Пример 3: Хеширование сырых двоичных данных

```nim
import std/hashes

proc hashFile(path: string): Hash =
  let data = readFile(path)
  # Вариант А: хешируем строку напрямую (трактуем содержимое как байты)
  result = hash(data)

proc hashBuffer(buf: ptr UncheckedArray[byte], len: int): Hash =
  # Вариант Б: используем hashData для сырого указателя + размера
  result = hashData(buf, len)

echo hashFile("mydata.bin")
```

---

### Пример 4: Проверка контракта хеширования

Демонстрация того, что равные объекты должны иметь равные хеши (на примере дробей):

```nim
import std/hashes

type
  Fraction = object
    num, den: int  # числитель, знаменатель — не обязательно в несократимом виде

# Две дроби равны, если перекрёстное произведение совпадает
proc `==`(a, b: Fraction): bool =
  a.num * b.den == b.num * a.den

# Правильный hash: сначала нормализуем до несократимого вида
proc gcd(a, b: int): int =
  var (a, b) = (a.abs, b.abs)
  while b != 0:
    a = a mod b
    swap a, b
  a

proc hash(f: Fraction): Hash =
  let g = gcd(f.num, f.den)
  var h: Hash = 0
  h = h !& hash(f.num div g)
  h = h !& hash(f.den div g)
  result = !$h

let half1 = Fraction(num: 1, den: 2)
let half2 = Fraction(num: 2, den: 4)  # то же значение, иное представление

assert half1 == half2              # равны по определению
assert hash(half1) == hash(half2)  # контракт соблюдён
```

---

### Пример 5: Использование `hashIdentity` для таблицы с плотными ключами

```nim
import std/[hashes, tables]

# Предположим, ID пользователей плотные (от 0 до N-1).
# hashIdentity позволяет избежать накладных расходов на перемешивание.
type UserId = distinct int

proc hash(id: UserId): Hash =
  hashIdentity(int(id))

proc `==`(a, b: UserId): bool {.borrow.}

var usernames: Table[UserId, string]
usernames[UserId(0)] = "alice"
usernames[UserId(1)] = "bob"
usernames[UserId(2)] = "carol"

echo usernames[UserId(1)]  # "bob"
```
