# Справочник модуля `encodings`

> **Стандартная библиотека Nim — `std/encodings`**
> Процедуры для конвертации строк между различными кодировками символов.
> На Unix используется библиотека `iconv`, на Windows — Windows API.

---

## Содержание

1. [Обзор и принцип работы](#обзор-и-принцип-работы)
2. [Типы](#типы)
   - [EncodingConverter](#encodingconverter)
   - [EncodingError](#encodingerror)
3. [Процедуры](#процедуры)
   - [getCurrentEncoding](#getcurrentencoding)
   - [open](#open)
   - [close](#close)
   - [convert (объект-конвертер)](#convert-объект-конвертер)
   - [convert (разовая конвертация)](#convert-разовая-конвертация)
4. [Справочник названий кодировок](#справочник-названий-кодировок)
5. [Платформенные особенности и ограничения](#платформенные-особенности-и-ограничения)
6. [Полные рабочие примеры](#полные-рабочие-примеры)

---

## Обзор и принцип работы

Модуль `encodings` решает одну конкретную задачу: **у вас есть строка байт, закодированная в кодировке X, а нужна она в кодировке Y**.

В Nim строка — это просто последовательность байт. Если текст закодирован в Latin-1, KOI8-R, Shift-JIS или любой другой кодировке, эти байты имеют иной смысл, чем в UTF-8. Модуль предоставляет инструменты для корректной переинтерпретации и перекодирования таких байт.

Есть два режима использования:

```
Режим 1: Разовая конвертация
─────────────────────────────
  convert(myString, destEncoding, srcEncoding)
  Открывает конвертер, выполняет преобразование, закрывает конвертер.
  Удобно для эпизодического использования.

Режим 2: Многократное использование конвертера
───────────────────────────────────────────────
  var c = open(destEncoding, srcEncoding)
  c.convert(string1)
  c.convert(string2)   ← конвертер переиспользуется, это эффективнее
  c.close()
```

Всю реальную работу по конвертации выполняет операционная система:
- На **Unix, macOS, BSD**: используется POSIX-библиотека `iconv`.
- На **Windows**: используются функции `MultiByteToWideChar` / `WideCharToMultiByte` из `kernel32.dll`, через промежуточное представление UTF-16.

---

## Типы

### `EncodingConverter`

```nim
# На Unix:
type EncodingConverter* = ptr ConverterObj

# На Windows:
type EncodingConverter* = object
  dest, src: CodePage
```

Дескриптор открытой сессии конвертации. Содержит информацию об исходной и целевой кодировках, а также внутреннее состояние, необходимое системной библиотеке. Для создания нужно вызвать `open()`, для освобождения ресурсов — `close()`.

Рассматривайте этот тип как непрозрачный дескриптор: не обращайтесь к его полям напрямую. Внутреннее представление различается в зависимости от платформы.

---

### `EncodingError`

```nim
type EncodingError* = object of ValueError
```

Тип исключения, сигнализирующего об ошибках, связанных с кодировками символов. Возникает в двух ситуациях:

1. **При открытии конвертера**: если одно или оба названия кодировок неизвестны или неподдерживаемы (например, опечатка в `"UTF-8"` или запрос `"UTF-32BE"` на Windows).
2. **На Windows**: при попытке конвертировать из `unicodeFFFE` (UTF-16 big-endian), `utf-32` или `utf-32BE` — кодировок, которые функция `MultiByteToWideChar` не может обработать как источник.

Поскольку `EncodingError` наследует от `ValueError`, его можно перехватить как `except ValueError` или более конкретно — `except EncodingError`.

---

## Процедуры

### `getCurrentEncoding`

```nim
proc getCurrentEncoding*(uiApp = false): string
```

**Что делает:** Возвращает название кодировки, которая в данный момент используется системой.

Поведение зависит от платформы:

- **На Unix/macOS/BSD**: всегда возвращает `"UTF-8"`, независимо от параметра `uiApp`. Современные Unix-системы стандартизировались на UTF-8, поэтому `iconv` не нуждается в знании «текущей» кодировки.
- **На Windows**: запрашивает Windows API. Если `uiApp` равен `false` (значение по умолчанию), возвращает кодировку **консоли** (кодовая страница, используемая в окне командной строки). Если `uiApp` равен `true`, возвращает **ANSI-кодовую страницу**, используемую GUI-приложениями — ту, в которой Windows хранит имена файлов и текст интерфейса.

**Параметр:**
- `uiApp` — флаг только для Windows. `false` → кодовая страница консоли (`GetConsoleCP`). `true` → ANSI/UI кодовая страница (`GetACP`).

```nim
import std/encodings

let enc = getCurrentEncoding()
echo enc  # "UTF-8" на Linux/macOS; например "windows-1251" на Windows с русской локалью

# На Windows: различить кодировки UI и консоли
let uiEnc   = getCurrentEncoding(uiApp = true)   # например "windows-1251"
let consEnc = getCurrentEncoding(uiApp = false)  # например "cp866"
```

**Практический случай использования:** Когда вы читаете файл неизвестной кодировки, но знаете, что он был создан на той же машине, `getCurrentEncoding()` даёт разумное предположение для параметра `srcEncoding`.

---

### `open`

```nim
proc open*(destEncoding = "UTF-8", srcEncoding = "CP1252"): EncodingConverter
```

**Что делает:** Создаёт и возвращает многоразовый `EncodingConverter`, настроенный на преобразование строк **из** `srcEncoding` **в** `destEncoding`. Это фабричная функция для объекта-конвертера.

Значения по умолчанию (`"UTF-8"` как назначение, `"CP1252"` как источник) отражают распространённый сценарий: преобразование устаревших западноевропейских текстовых файлов в современный UTF-8.

**Параметры:**
- `destEncoding` — кодировка, в которой должна быть выходная строка.
- `srcEncoding` — кодировка, в которой в данный момент находится входная строка.

**Выбрасывает `EncodingError`**, если название хотя бы одной из кодировок неизвестно системе (`iconv` на Unix, таблица кодовых страниц Windows на Windows).

```nim
import std/encodings

# Конвертер из KOI8-R (старая русская кодировка) в UTF-8
var c = open("UTF-8", "KOI8-R")

let russianKoi8 = "\xf0\xd2\xc9\xd7\xc5\xd4"  # "Привет" в байтах KOI8-R
echo c.convert(russianKoi8)  # Привет

c.close()
```

```nim
# Конвертация текста в Shift-JIS (японский, типично для старых Windows-файлов) в UTF-8
var toUtf8 = open("UTF-8", "shift_jis")
defer: toUtf8.close()

let sjisBytes = "\x82\xb1\x82\xf1\x82\xc9\x82\xbf\x82\xcd"  # こんにちは в Shift-JIS
echo toUtf8.convert(sjisBytes)  # こんにちは
```

---

### `close`

```nim
proc close*(c: EncodingConverter)
```

**Что делает:** Освобождает все ресурсы, которыми владеет конвертер. На Unix вызывает `iconv_close()`, освобождая внутреннее состояние библиотеки. На Windows никаких ресурсов ОС освобождать не нужно (конвертер — это простой объект-значение), поэтому вызов является холостым, но по-прежнему рекомендуется для переносимости кода и ясности намерений.

Всегда вызывайте `close()` по завершении работы с конвертером — особенно в долго живущих программах, чтобы избежать утечки дескрипторов `iconv`. Идиоматичный Nim-паттерн — использовать `defer`:

```nim
var c = open("UTF-8", "iso-8859-2")
defer: c.close()  # выполнится гарантированно, даже если будет выброшено исключение

let result = c.convert(myInput)
```

---

### `convert` (объект-конвертер)

```nim
proc convert*(c: EncodingConverter, s: string): string
```

**Что делает:** Конвертирует строку `s` из исходной кодировки конвертера в целевую и возвращает результат как новую строку. Это основная операция модуля.

Данную процедуру можно вызывать на одном конвертере любое число раз — конвертер не хранит состояние между вызовами (каждый вызов независим). Благодаря этому многократное использование одного конвертера для обработки большого количества строк в цикле является эффективным.

**На Unix (iconv):** Неизвестные или непредставимые символы копируются в вывод как есть (сырой байт), а не вызывают ошибку. Выходной буфер при необходимости динамически расширяется. Финальный сброс буфера (`flush`) гарантирует корректную обработку многобайтовых последовательностей в конце входных данных.

**На Windows:** Делегирует вызовы `MultiByteToWideChar` (источник → UTF-16), затем `WideCharToMultiByte` (UTF-16 → назначение). Пустая строка обрабатывается как особый случай, поскольку Windows API при нулевой длине возвращает 0 — то же значение, что и при ошибке.

```nim
import std/encodings

var fromLatin2 = open("UTF-8", "iso-8859-2")
defer: fromLatin2.close()

# Обрабатываем список строк — конвертер создаётся один раз
let sentences = [
  "\xe8l\xf3vek",  # "člóvek" в ISO-8859-2
  "Dob\xfd den",   # "Dobrý den" в ISO-8859-2
]

for s in sentences:
  echo fromLatin2.convert(s)
```

---

### `convert` (разовая конвертация)

```nim
proc convert*(s: string, destEncoding = "UTF-8", srcEncoding = "CP1252"): string
```

**Что делает:** Вспомогательная процедура, которая открывает конвертер, конвертирует `s`, закрывает конвертер и возвращает результат — всё за один вызов. Это самый простой способ выполнить единичную конвертацию.

Значения по умолчанию совпадают с `open()`: назначение `"UTF-8"`, источник `"CP1252"` (Windows, Западная Европа).

**Выбрасывает `EncodingError`**, если название одной из кодировок неизвестно.

**Замечание о производительности:** Поскольку при каждом вызове открывается и закрывается конвертер, здесь присутствуют накладные расходы на инициализацию/завершение. Для конвертации одной строки это несущественно. При конвертации сотен или тысяч строк предпочтительнее использовать многоразовый `EncodingConverter` из `open()`.

```nim
import std/encodings

# Просто: конвертировать строку CP1252 в UTF-8
let utf8 = convert("\xe9l\xe8ve")  # élève в CP1252 → UTF-8

# Явное указание кодировок
let koi8text = "\xf0\xd2\xc9\xd7\xc5\xd4"
echo convert(koi8text, destEncoding = "UTF-8", srcEncoding = "KOI8-R")  # Привет

# Туда и обратно: UTF-8 → ISO-8859-1 → UTF-8
let original = "Héllo"
let latin1   = convert(original, "iso-8859-1", "UTF-8")
let restored = convert(latin1,   "UTF-8",      "iso-8859-1")
assert original == restored
```

---

## Справочник названий кодировок

Названия кодировок **нечувствительны к регистру**, а **дефисы и подчёркивания взаимозаменяемы** при поиске в таблице Windows (например, `"UTF-8"`, `"utf-8"` и `"utf_8"` равнозначны). На Unix `iconv` также принимает множество псевдонимов, но точное поведение зависит от установленной версии iconv.

Ниже приведён список наиболее часто используемых кодировок:

| Название(я) | Описание |
|---|---|
| `UTF-8` | Unicode, переменная ширина, повсеместно используемая кодировка |
| `UTF-16` | Unicode, little-endian (нативные wide-char Windows) |
| `UTF-32` | Unicode, little-endian, 32 бита (**не поддерживается на Windows**) |
| `UTF-32BE` | Unicode, big-endian, 32 бита (**не поддерживается на Windows**) |
| `unicodeFFFE` | UTF-16, big-endian (**не поддерживается на Windows как источник**) |
| `us-ascii` | 7-битный ASCII |
| `iso-8859-1` | Latin-1, Западная Европа |
| `iso-8859-2` | Latin-2, Центральная Европа (чешский, польский, словацкий…) |
| `iso-8859-5` | Кириллица |
| `iso-8859-7` | Греческий |
| `iso-8859-8` | Иврит |
| `windows-1250` / `cp-1250` | Windows, Центральная Европа |
| `windows-1251` / `cp-1251` | Windows, Кириллица |
| `windows-1252` / `cp-1252` | Windows, Западная Европа (значение srcEncoding по умолчанию) |
| `windows-1253` / `cp-1253` | Windows, Греческий |
| `koi8-r` | KOI8-R, русский (традиция Unix) |
| `koi8-u` | KOI8-U, украинский |
| `cp866` | DOS, кириллица |
| `ibm850` | DOS, Западная Европа (OEM Latin-1) |
| `shift_jis` | Японский (Windows/Shift-JIS) |
| `gb2312` / `gbk` | Китайский упрощённый |
| `big5` | Китайский традиционный |
| `euc-jp` | Японский EUC |
| `euc-kr` | Корейский EUC |
| `ks_c_5601-1987` | Корейский (Unified Hangul Code) |
| `iso-2022-jp` | Японский (JIS, 7-бит) |

На Windows можно также использовать числовой номер кодовой страницы в виде строки: `"1251"`, `"866"` и т.д.

---

## Платформенные особенности и ограничения

**UTF-16BE, UTF-32, UTF-32BE на Windows**

Windows API направляет все конвертации через UTF-16 Little-Endian как промежуточное представление. Кодировки, которые сами по себе являются широкосимвольными форматами в big-endian или 32-битном варианте, не могут быть использованы как *источник* конвертации через `MultiByteToWideChar`. Попытка сделать это вызывает `EncodingError` с поясняющим сообщением. В качестве *назначения* эти кодировки также не поддерживаются. Если вам нужны подобные конвертации на Windows, реализуйте их вручную или используйте сторонние библиотеки.

**Неизвестные/непредставимые символы на Unix**

На Unix, если последовательность байт во входных данных не может быть отображена в целевую кодировку, сырой байт копируется в вывод дословно (символ «пропускается», а не заменяется суррогатом). Это означает, что вывод может содержать некорректные последовательности, если исходная кодировка была указана неверно. Исключение при этом не выбрасывается.

**Пустая строка на Windows**

Функция Windows `MultiByteToWideChar` возвращает `0` как в случае успеха с нулевой длиной вывода, так и в случае ошибки. Модуль обрабатывает пустую строку как особый случай (`if s.len == 0: return ""`) до вызова API, поэтому пустой ввод всегда даёт пустой вывод без ошибки.

**Доступность iconv на Unix**

На Linux и macOS `iconv` является частью стандартной библиотеки C. На BSD-системах модуль явно линкуется с `-liconv` (OpenBSD). На Haiku динамически загружается `libiconv.so`. Если `iconv` недоступен на вашей целевой платформе, модуль не скомпилируется или не слинкуется.

---

## Полные рабочие примеры

### Пример 1: Прочитать текстовый файл в устаревшей кодировке и вывести его как UTF-8

Типичный сценарий: у вас есть файл, сохранённый старым Windows-приложением в CP1251 (кириллица) или другой системной кодировке, и вам нужно отобразить или обработать его в UTF-8.

```nim
import std/[encodings, streams]

proc readAsUtf8(filename: string, srcEncoding: string): string =
  var f = newFileStream(filename, fmRead)
  if f == nil:
    raise newException(IOError, "Не удалось открыть " & filename)
  defer: f.close()

  let raw = f.readAll()
  result = convert(raw, destEncoding = "UTF-8", srcEncoding = srcEncoding)

# Читаем файл, сохранённый в Windows-кириллице (CP1251)
let text = readAsUtf8("document.txt", "windows-1251")
echo text
```

---

### Пример 2: Пакетная конвертация множества строк с максимальной эффективностью

Когда нужно конвертировать большое количество строк, создание многоразового конвертера позволяет избежать накладных расходов на открытие и закрытие дескриптора системной библиотеки при каждом вызове.

```nim
import std/encodings

proc convertAll(strings: seq[string], src, dest: string): seq[string] =
  var c = open(dest, src)
  defer: c.close()
  result = newSeq[string](strings.len)
  for i, s in strings:
    result[i] = c.convert(s)

let raw = @[
  "\xcf\xf0\xe8\xe2\xe5\xf2",   # "Привет" в CP1251
  "\xc4\xee\xe1\xf0\xfb\xe9",   # "Добрый" в CP1251
  "\xe4\xe5\xed\xfc",            # "день"   в CP1251
]

let utf8Strings = convertAll(raw, "windows-1251", "UTF-8")
for s in utf8Strings:
  echo s
# Привет
# Добрый
# день
```

---

### Пример 3: Определить текущую системную кодировку и адаптироваться к ней

Программа, которая читает стандартный ввод и выводит UTF-8, не зависимо от текущей системной кодировки.

```nim
import std/[encodings, os]

let sysEnc = getCurrentEncoding()
echo "Системная кодировка: ", sysEnc

if sysEnc == "UTF-8":
  # Уже UTF-8 — просто передаём как есть
  echo stdin.readAll()
else:
  var c = open("UTF-8", sysEnc)
  defer: c.close()
  echo c.convert(stdin.readAll())
```

---

### Пример 4: Безопасная конвертация с обработкой ошибок

Демонстрация перехвата `EncodingError` при передаче некорректных названий кодировок.

```nim
import std/encodings

proc safeConvert(s, dest, src: string): string =
  try:
    result = convert(s, dest, src)
  except EncodingError as e:
    echo "Ошибка кодировки: ", e.msg
    result = s  # возвращаем оригинал как запасной вариант

# Корректная конвертация
echo safeConvert("hello", "UTF-8", "us-ascii")  # hello

# Неверное название кодировки → EncodingError перехватывается
echo safeConvert("hello", "UTF-8", "несуществующая_кодировка")
# Ошибка кодировки: cannot create encoding converter from несуществующая_кодировка to UTF-8
# hello  ← запасной вариант
```

---

### Пример 5: Проверка конвертации туда и обратно

Полезно для проверки правильности предположения об исходной кодировке: конвертируем в промежуточную кодировку и обратно, затем сравниваем с оригиналом.

```nim
import std/encodings

proc roundTripCheck(original: string, intermediate: string): bool =
  let encoded  = convert(original, intermediate, "UTF-8")
  let restored = convert(encoded,  "UTF-8",      intermediate)
  result = (restored == original)

let text = "Héllo Wörld"
echo roundTripCheck(text, "iso-8859-1")  # true  — все символы помещаются в Latin-1
echo roundTripCheck(text, "us-ascii")    # false — é и ö не входят в ASCII

let russian = "Привет"
echo roundTripCheck(russian, "windows-1251")  # true  — кириллица корректно кодируется в CP1251
echo roundTripCheck(russian, "iso-8859-1")    # false — кириллицы нет в Latin-1
```
