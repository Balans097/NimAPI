# std/random — справочник по модулю

> Стандартный генератор псевдослучайных чисел (ГПСЧ) Nim, основанный на алгоритме **xoroshiro128+**.
>
> ⚠️ **Этот модуль категорически нельзя использовать в криптографических целях.** Для криптографически стойкой случайности используйте [`std/sysrand`](https://nim-lang.org/docs/sysrand.html).

---

## Содержание

1. [Ключевые концепции](#ключевые-концепции)
2. [Типы](#типы)
3. [Инициализация и посев](#инициализация-и-посев)
4. [Семейство `rand`](#семейство-rand)
5. [Выборка — `sample`](#выборка--sample)
6. [Перемешивание — `shuffle`](#перемешивание--shuffle)
7. [Гауссово распределение](#гауссово-распределение)
8. [Низкоуровневые и продвинутые возможности](#низкоуровневые-и-продвинутые-возможности)
9. [Потокобезопасность](#потокобезопасность)
10. [Сводная таблица](#сводная-таблица)

---

## Ключевые концепции

### Глобальный ГПСЧ vs. явный `Rand`

Каждая процедура модуля существует в двух вариантах:

- **Глобальный вариант** — без параметра `Rand`. Использует единственное глобальное состояние на весь модуль. Удобен для простых программ, но **не потокобезопасен** и всегда стартует с одного и того же зерна, если не вызвать `randomize()`.
- **Явный вариант** — принимает `var Rand` первым параметром. Полностью автономен; несколько независимых генераторов могут существовать одновременно. Обязателен для корректной многопоточной работы.

### Воспроизводимость

Если перед использованием любого proc из этого модуля вызвать `randomize()`, генератор инициализируется из системного источника случайности и будет давать разные результаты при каждом запуске. Если `randomize()` не вызывать, генератор всегда стартует с одного и того же фиксированного зерна и производит одну и ту же последовательность — это полезно для воспроизводимых тестов.

---

## Типы

### `Rand`

```nim
type Rand* = object
  a0, a1: Ui  # внутренние поля состояния (приватные)
```

Полное состояние одного экземпляра генератора случайных чисел. Это обычный тип-значение (`object`, не `ref`), поэтому его можно копировать, хранить в массивах и передавать между потоками — но каждый поток должен работать **с собственной копией**.

Создание `Rand`:

```nim
var r = initRand(42)    # из фиксированного зерна
var r = initRand()      # из системного источника случайности
```

---

### `randState` (шаблон)

```nim
template randState*(): untyped
```

Предоставляет прямой доступ к внутреннему глобальному состоянию `Rand` для других модулей библиотеки. Полезен авторам модулей, построенных поверх `std/random`. В обычном прикладном коде этот шаблон не нужен.

---

## Инициализация и посев

### `initRand(seed)` — инициализация с фиксированным зерном

```nim
proc initRand*(seed: int64): Rand
```

Создаёт новое состояние `Rand`, засеянное конкретным целым числом. Одно и то же зерно всегда порождает одну и ту же последовательность — это делает функцию идеальной для воспроизводимых симуляций, тестов и процедурной генерации.

Если `seed == 0`, автоматически используется внутренний ненулевой запасной вариант (потому что ноль является вырожденной фиксированной точкой алгоритма).

```nim
var r = initRand(42)
echo r.rand(100)   # всегда одно и то же значение для зерна 42
```

Чтобы получать разные результаты при каждом запуске, засевайте от текущего времени:

```nim
import std/times
let now = getTime()
var r = initRand(now.toUnix * 1_000_000_000 + now.nanosecond)
```

---

### `initRand()` — автоматическая инициализация

```nim
proc initRand(): Rand
```

Создаёт состояние `Rand`, засеянное автоматически из системного источника случайности (`sysrand.urandom` на нативных платформах, `epochTime` на JS). Результирующее состояние не зависит от глобального ГПСЧ. Предпочтительный способ инициализации генератора на поток или на объект, когда воспроизводимость не требуется.

> **Примечание:** Не работает в виртуальной машине времени компиляции (NimScript).

```nim
var r = initRand()   # уникально при каждом запуске программы
```

---

### `randomize(seed)` — засев глобального ГПСЧ

```nim
proc randomize*(seed: int64)
```

Переинициализирует **глобальный** ГПСЧ конкретным целочисленным зерном. После этого все глобальные варианты proc (`rand(100)`, `sample(arr)` и т. д.) будут выдавать детерминированную последовательность, соответствующую данному зерну.

```nim
randomize(123)
echo rand(100)   # одно и то же значение при каждом запуске с зерном 123
```

---

### `randomize()` — засев глобального ГПСЧ из системы

```nim
proc randomize()
```

Переинициализирует глобальный ГПСЧ из системного источника случайности. Вызывать **один раз**, в самом начале программы, перед любым использованием глобальных вариантов proc. Это самый важный вызов в любой программе, которой нужна непредсказуемая случайность.

```nim
randomize()      # один раз в начале программы
echo rand(100)   # разное при каждом запуске
```

> **Примечание:** Не работает в виртуальной машине времени компиляции.

---

## Семейство `rand`

`rand` перегружен для разных типов аргументов. Нужный вариант выбирается автоматически по типу аргумента.

---

### `rand(max: int)` / `r.rand(max: Natural)` — целое число в `0..max`

```nim
proc rand*(max: int): int
proc rand*(r: var Rand; max: Natural): int
```

Возвращает равномерно распределённое целое число в **замкнутом** диапазоне `0..max` (оба конца включены). Верхняя граница входит в возможные результаты.

```nim
let n = rand(9)        # одно из 0, 1, 2, … 9
var r = initRand(1)
let m = r.rand(9)      # тот же диапазон, явное состояние
```

Распространённая ошибка — воспринимать `rand(n)` как аналог `0..<n`. Это не так: `n` включается в результат. Чтобы получить индекс в массив длиной `n`, используйте `rand(n - 1)` или срезовую форму `rand(0..<n)`.

---

### `rand(max: float)` / `r.rand(max: ...)` — вещественное число в `0.0..max`

```nim
proc rand*(max: float): float
proc rand*(r: var Rand; max: range[0.0..high(float)]): float
```

Возвращает равномерно распределённое вещественное число в `[0.0, max]`. Реализация использует битовые манипуляции над сырым выводом `uint64` генератора для равномерного распределения по представимым числам с плавающей точкой в данном диапазоне — без систематического смещения.

```nim
let f = rand(1.0)     # в [0.0, 1.0]
let p = rand(100.0)   # случайный процент
```

---

### `rand(x: HSlice)` / `r.rand(x: HSlice)` — значение из среза

```nim
proc rand*[T: Ordinal or SomeFloat](x: HSlice[T, T]): T
proc rand*[T: Ordinal or SomeFloat](r: var Rand; x: HSlice[T, T]): T
```

Наиболее гибкая форма `rand`. Для среза `a..b` возвращает значение, равномерно распределённое в `[a, b]`. Работает для целых чисел, вещественных чисел и **перечислений без «дыр»**.

```nim
let кубик   = rand(1..6)            # классический кубик
let темп    = rand(-20.0 .. 40.0)   # вещественное из диапазона
let шанс    = rand(0.0 .. 1.0)      # вероятность
```

Для перечислений все значения в диапазоне равновероятны:

```nim
type Direction = enum North, East, South, West
let dir = rand(North..West)
```

---

### `rand(t: typedesc[T])` / `r.rand(t: typedesc[T])` — весь диапазон типа

```nim
proc rand*[T: Ordinal](t: typedesc[T]): T
proc rand*[T: Ordinal](r: var Rand; t: typedesc[T]): T
```

Возвращает случайное значение, охватывающее **весь** диапазон типа `T` — от `low(T)` до `high(T)`. Работает для любых ординальных типов: целых, булевых, перечислений и диапазонных типов.

```nim
let b  = rand(bool)           # true или false, 50/50
let c  = rand(char)           # любой символ 0..255
let i8 = rand(int8)           # любой int8 (-128..127)
let u  = rand(uint32)         # любой uint32

type Color = enum Red, Green, Blue
let col = rand(Color)         # любое значение Color
```

Это самый чистый способ получить равномерно случайное значение типа, когда нужно, чтобы каждое возможное значение было одинаково вероятно.

---

## Выборка — `sample`

### `sample(a: openArray[T])` / `r.sample(a)` — случайный элемент массива

```nim
proc sample*[T](a: openArray[T]): lent T
proc sample*[T](r: var Rand; a: openArray[T]): T
```

Возвращает равномерно случайный элемент из массива или последовательности `a`. Все элементы имеют одинаковую вероятность. Массив должен быть непустым (иначе — ошибка выхода за пределы индекса).

```nim
let colors = ["красный", "зелёный", "синий"]
let pick = sample(colors)   # один из трёх, с равной вероятностью

var r = initRand(1)
let pick2 = r.sample(colors)
```

---

### `sample(s: set[T])` / `r.sample(s)` — случайный элемент множества

```nim
proc sample*[T](s: set[T]): T
proc sample*[T](r: var Rand; s: set[T]): T
```

Возвращает равномерно случайный элемент из Nim-множества `set`. Множество должно быть непустым. Поскольку множества не имеют гарантированного порядка, элемент выбирается подсчётом: вычисляется случайный индекс в мощность множества, затем множество обходится до нужного элемента.

```nim
let нечётные = {1, 3, 5, 7, 9}
echo sample(нечётные)   # одно из пяти нечётных чисел
```

---

### `sample(a, cdf)` / `r.sample(a, cdf)` — взвешенная выборка по КФР

```nim
proc sample*[T, U](a: openArray[T]; cdf: openArray[U]): T
proc sample*[T, U](r: var Rand; a: openArray[T]; cdf: openArray[U]): T
```

Возвращает случайный элемент из `a` согласно **кумулятивной функции распределения** (КФР), хранящейся в `cdf`. Это обеспечивает взвешенный случайный выбор: элементы с большим весом имеют большую вероятность.

`cdf` должен иметь ту же длину, что и `a`, его значения должны быть неубывающими, а последнее значение — положительным. Нормировка до конкретного максимума не требуется. Proc `math.cumsummed` — естественный способ построить КФР из массива счётчиков или весов.

```nim
import std/math

let призы   = ["джекпот", "машина", "велосипед", "ручка", "ничего"]
let веса    = [1,         5,        20,           100,     500     ]
let cdf     = веса.cumsummed
# cdf == [1, 6, 26, 126, 626]
# «ничего» имеет вероятность 500/626 ≈ 80%

randomize()
echo sample(призы, cdf)   # скорее всего «ничего»
```

Подход с КФР значительно эффективнее для больших массивов, чем повторные вызовы `sample` с отбрасыванием: каждый вызов работает за O(log n) через двоичный поиск.

---

## Перемешивание — `shuffle`

### `shuffle(x)` / `r.shuffle(x)` — перемешивание на месте (Фишер-Йетс)

```nim
proc shuffle*[T](x: var openArray[T])
proc shuffle*[T](r: var Rand; x: var openArray[T])
```

Переставляет элементы `x` в равномерно случайную перестановку на месте. Используется алгоритм Фишера-Йетса, который гарантирует одинаковую вероятность для каждой возможной перестановки.

```nim
var колода = ["A", "2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K"]
randomize()
shuffle(колода)   # колода теперь в случайном порядке

var r = initRand(42)
r.shuffle(колода)   # воспроизводимое перемешивание с явным состоянием
```

`shuffle` изменяет последовательность на месте и ничего не возвращает. Исходный порядок теряется.

---

## Гауссово распределение

### `gauss(mu, sigma)` / `r.gauss(mu, sigma)` — нормально распределённое вещественное число

```nim
proc gauss*(mu = 0.0, sigma = 1.0): float
proc gauss*(r: var Rand; mu = 0.0; sigma = 1.0): float
```

Возвращает вещественное случайное число, взятое из **нормального (гауссова) распределения** со средним `mu` и среднеквадратическим отклонением `sigma`. Параметры по умолчанию (`mu = 0.0`, `sigma = 1.0`) соответствуют стандартному нормальному распределению.

Реализация использует метод отношения равномерных случайных чисел (ratio of uniforms) — эффективный и численно устойчивый.

```nim
# Рост взрослых: среднее 170 см, СКО 10 см
randomize()
let рост = gauss(mu = 170.0, sigma = 10.0)

# Шум в симуляции
var r = initRand(7)
let шум = r.gauss(0.0, 0.01)   # малое гауссово возмущение
```

В отличие от `rand`, дающего равномерное распределение, `gauss` даёт колоколообразное распределение: около 68% значений попадают в диапазон `mu ± sigma`, около 95% — в `mu ± 2*sigma`.

---

## Низкоуровневые и продвинутые возможности

### `next(r)` — сырой 64-битный вывод

```nim
proc next*(r: var Rand): uint64
```

Продвигает состояние генератора на один шаг и возвращает необработанный 64-битный вывод алгоритма xoroshiro128+. Именно на этом примитиве построены все остальные процедуры модуля.

`next` нужен непосредственно только тогда, когда вы создаёте нестандартное распределение или вам нужна максимальная пропускная способность генератора без каких-либо масштабирований и преобразований.

```nim
var r = initRand(2019)
let raw = r.next()   # сырое 64-битное псевдослучайное значение
```

Последовательные вызовы `next` дают значения, хорошо равномерно распределённые по всем 64 битам, хотя отдельные биты или небольшие подмножества могут иметь слабые корреляции, типичные для семейства xoroshiro-генераторов.

---

### `skipRandomNumbers(s)` — прыжок на 2⁶⁴ шагов вперёд

```nim
proc skipRandomNumbers*(s: var Rand)
```

Продвигает состояние `Rand` на **2⁶⁴** шагов за одну операцию O(1) — как если бы `next` был вызван столько раз. Это позволяет разбить вывод генератора на непересекающиеся подпоследовательности для параллельных вычислений.

Канонический шаблон для многопоточности: создать один `Rand`, передать поток 0, вызвать `skipRandomNumbers`, передать потоку 1, снова вызвать, передать потоку 2 — и так далее. Каждый поток получает отдельную подпоследовательность из 2⁶⁴ значений, которая никогда не пересечётся с другими — при условии, что ни один поток не сгенерирует более 2⁶⁴ чисел.

```nim
var r = initRand(2024)

var r0 = r              # поток 0 получает это состояние
r.skipRandomNumbers()
var r1 = r              # поток 1 получает это состояние
r.skipRandomNumbers()
var r2 = r              # поток 2 получает это состояние
# r0, r1, r2 никогда не произведут пересекающиеся последовательности
```

---

## Потокобезопасность

Глобальные варианты proc (без параметра `Rand`) **не потокобезопасны**, поскольку все они читают и пишут одну и ту же глобальную переменную `state` без какой-либо синхронизации.

Для корректной генерации случайных чисел в многопоточной программе:

1. Создайте отдельное состояние `Rand` для каждого потока с помощью `initRand()` или `initRand(seed)`.
2. Используйте исключительно явные перегрузки (`r.rand(...)`, `r.sample(...)` и т. д.).
3. Если последовательности должны быть гарантированно непересекающимися, используйте `skipRandomNumbers` для распределения пространства состояний по потокам.

```nim
# Корректный многопоточный шаблон
proc workerThread(seed: int64) {.thread.} =
  var r = initRand(seed)          # каждый поток владеет своим состоянием
  for _ in 1..1000:
    echo r.rand(0..100)           # безопасно — нет общего состояния

# Или: использовать skipRandomNumbers для непересекающихся подпоследовательностей:
var r = initRand()
for i in 0..<numThreads:
  let threadState = r             # копируем текущее состояние потоку i
  r.skipRandomNumbers()           # продвигаем глобальное состояние для следующего потока
  createThread(threads[i], worker, threadState)
```

---

## Сводная таблица

| Процедура / Шаблон | Что делает |
|---|---|
| `initRand(seed)` | Создать `Rand` из фиксированного зерна |
| `initRand()` | Создать `Rand` из системного источника случайности |
| `randomize(seed)` | Засеять глобальный ГПСЧ фиксированным значением |
| `randomize()` | Засеять глобальный ГПСЧ из системного источника |
| `rand(max: int)` | Целое в `0..max` (глобальный ГПСЧ) |
| `r.rand(max: Natural)` | Целое в `0..max` (явное состояние) |
| `rand(max: float)` | Вещественное в `0.0..max` (глобальный ГПСЧ) |
| `r.rand(max: float)` | Вещественное в `0.0..max` (явное состояние) |
| `rand(a..b)` | Случайное значение в срезе `a..b` (глобальный ГПСЧ) |
| `r.rand(a..b)` | Случайное значение в срезе `a..b` (явное состояние) |
| `rand(T)` | Случайное по всему диапазону типа `T` (глобальный ГПСЧ) |
| `r.rand(T)` | Случайное по всему диапазону типа `T` (явное состояние) |
| `sample(arr)` | Случайный элемент массива/последовательности (глобальный ГПСЧ) |
| `r.sample(arr)` | Случайный элемент массива/последовательности (явное состояние) |
| `sample(s: set)` | Случайный элемент множества (глобальный ГПСЧ) |
| `r.sample(s: set)` | Случайный элемент множества (явное состояние) |
| `sample(arr, cdf)` | Взвешенный случайный элемент по КФР (глобальный ГПСЧ) |
| `r.sample(arr, cdf)` | Взвешенный случайный элемент по КФР (явное состояние) |
| `shuffle(arr)` | Перемешивание Фишера-Йетса на месте (глобальный ГПСЧ) |
| `r.shuffle(arr)` | Перемешивание Фишера-Йетса на месте (явное состояние) |
| `gauss(mu, sigma)` | Нормально распределённое вещественное (глобальный ГПСЧ) |
| `r.gauss(mu, sigma)` | Нормально распределённое вещественное (явное состояние) |
| `r.next()` | Сырой `uint64`-вывод генератора |
| `r.skipRandomNumbers()` | Прыжок на 2⁶⁴ шагов вперёд (для параллельного использования) |
| `randState()` | Доступ к глобальному состоянию `Rand` модуля |
