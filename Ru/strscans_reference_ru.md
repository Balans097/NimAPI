# std/strscans — справочник по модулю

> Сканирование строк по шаблону в Nim. Предоставляет макросы `scanf` и `scanp`
> для извлечения структурированных данных из строк — зачастую проще и быстрее
> регулярных выражений, без накладных расходов в рантайме, поскольку шаблоны
> компилируются на этапе компиляции.

---

## Содержание

1. [Ключевые концепции](#ключевые-концепции)
2. [`scanf` — шаблонный макрос](#scanf--шаблонный-макрос)
   - [Встроенные токены формата](#встроенные-токены-формата)
   - [Буквальное совпадение](#буквальное-совпадение)
   - [Полное совпадение vs. совпадение с начала](#полное-совпадение-vs-совпадение-с-начала)
   - [Отсутствие отката](#отсутствие-отката)
3. [`scanTuple` — вариант с возвратом кортежа](#scantuple--вариант-с-возвратом-кортежа)
4. [Пользовательские матчеры](#пользовательские-матчеры)
   - [`${proc}` — матчер с привязкой](#proc--матчер-с-привязкой)
   - [`$[proc]` — матчер-скипер](#proc--матчер-скипер)
   - [Передача аргументов матчерам](#передача-аргументов-матчерам)
5. [`scanp` — грамматический макрос](#scanp--грамматический-макрос)
   - [Операторы грамматики](#операторы-грамматики)
   - [`$_` и привязка действий (`->`)](#_-и-привязка-действий---)
   - [Вызов Nim-процедур внутри `scanp`](#вызов-nim-процедур-внутри-scanp)
   - [Пользовательские типы входных данных](#пользовательские-типы-входных-данных)
6. [Вспомогательные шаблоны для пользовательских типов](#вспомогательные-шаблоны-для-пользовательских-типов)
7. [Совместное использование `scanf` и `scanp`](#совместное-использование-scanf-и-scanp)
8. [Сводная шпаргалка](#сводная-шпаргалка)

---

## Ключевые концепции

`std/strscans` предоставляет два взаимодополняющих инструмента сканирования:

**`scanf`** работает аналогично C-шному `scanf`: вы задаёте *строку шаблона* с `$`-токенами, перемежающимися с буквальным текстом, и макрос пытается сопоставить входную строку слева направо, записывая захваченные значения в ваши переменные. Шаблон — константа времени компиляции, поэтому макрос разворачивает его в эффективный инлайн-код; интерпретатора шаблонов в рантайме нет.

**`scanp`** выражает шаблоны через Nim-выражения с PEG/EBNF-подобными операторами (`*`, `+`, `?`, `~`, `{n,m}`, `->` и др.). Мощнее и гибче, но многословнее. Принимает изменяемую переменную индекса, что идеально для инкрементального сканирования в цикле.

Оба макроса выполняются **без отката**: как только часть шаблона потребила входные данные, это потребление не отменяется при неудаче более поздней части.

---

## `scanf` — шаблонный макрос

```nim
macro scanf*(input: string; pattern: static[string]; results: varargs[typed]): bool
```

Пытается сопоставить `input` с `pattern`. Возвращает `true`, если сопоставление успешно (шаблон удовлетворяется начиная с начала `input`). Захваченные значения записываются в переменные `results` в том порядке, в котором токены появляются в шаблоне.

```nim
var x, y, z: int
if scanf("(1,2,4)", "($i,$i,$i)", x, y, z):
  echo x, " ", y, " ", z   # 1 2 4
```

Шаблон — это **константа времени компиляции** (строковый литерал или `const`). Nim разрешает его на этапе компиляции и генерирует соответствующие вызовы разбора напрямую — накладных расходов на интерпретацию строки форматирования нет.

---

### Встроенные токены формата

Каждый токен начинается с `$`, за которым следует буква. Токен потребляет подстроку из входных данных и — там, где применимо — записывает разобранное значение в следующую переменную из списка `results`.

| Токен | Тип захвата | Описание |
|---|---|---|
| `$i` | `int` | Десятичное целое. Использует `parseutils.parseInt`. |
| `$b` | `int` | Двоичное целое (например `0b1010`). Использует `parseutils.parseBin`. |
| `$o` | `int` | Восьмеричное целое (например `0o17`). Использует `parseutils.parseOct`. |
| `$h` | `int` | Шестнадцатеричное целое (например `0xFF`). Использует `parseutils.parseHex`. |
| `$f` | `float` | Вещественное число. Использует `parseutils.parseFloat`. |
| `$w` | `string` | ASCII-идентификатор: `[A-Za-z_][A-Za-z_0-9]*`. |
| `$c` | `char` | Один ASCII-символ. |
| `$s` | — | Пропускает ноль или более пробельных символов. Никогда не завершается неудачей. |
| `$$` | — | Соответствует буквальному символу `$`. |
| `$.` | — | Успешен только если достигнут конец входной строки. Должен быть последним. |
| `$*` | `string` | Соответствует вплоть до следующего буквального токена в шаблоне. Длина 0 допустима. |
| `$+` | `string` | Как `$*`, но требует хотя бы одного символа. |
| `${proc}` | зависит | Вызов пользовательского матчера с привязкой. См. [Пользовательские матчеры](#пользовательские-матчеры). |
| `$[proc]` | — | Вызов пользовательского матчера-скипера (без привязки переменной). |

```nim
var year, month, day: int
var name: string
var temp: float

# Разбор "2024-03-15 London 18.5"
if scanf("2024-03-15 London 18.5", "$i-$i-$i $w$s$f",
         year, month, day, name, temp):
  echo year, "-", month, "-", day   # 2024-3-15
  echo name, " ", temp              # London 18.5
```

---

### `$*` и `$+` — совпадение до разделителя

Эти два токена захватывают всё вплоть до следующей *буквальной* строки в шаблоне. Внутренне используют `parseutils.parseUntil`.

```nim
var proto, host, path: string

# Разбор простого URL: "https://example.com/index.html"
if scanf("https://example.com/index.html", "$*://$*$+", proto, host, path):
  echo proto   # https
  echo host    # example.com
  echo path    # /index.html
```

`$*` принимает пустое совпадение (разделитель найден немедленно), а `$+` требует хотя бы один символ перед разделителем. Если буквальный токен-разделитель не следует за `$*`/`$+` в шаблоне, токен соответствует до конца строки.

---

### Буквальное совпадение

Любая часть шаблона, не начинающаяся с `$`, сопоставляется с входными данными дословно. Совпадение регистрозависимое. Если буквальный текст не найден в текущей позиции, весь `scanf` возвращает `false`.

```nim
var n: int
# Буквальное "item:" должно присутствовать
if scanf("item:42", "item:$i", n):
  echo n   # 42
```

---

### Полное совпадение vs. совпадение с начала

По умолчанию `scanf` возвращает `true`, как только шаблон выполнен, даже если во входной строке остались символы. Добавьте `$.` в конец шаблона, чтобы потребовать потребления всей строки.

```nim
var n: int

# Совпадение с начала — успешно даже при наличии хвоста
if scanf("42abc", "$i", n): echo "с начала: ", n   # 42

# Полное совпадение — требует отсутствия символов после числа
if scanf("42", "$i$.", n): echo "полное: ", n       # 42
if scanf("42abc", "$i$.", n): echo "никогда"        # НЕ печатается
```

`$.` должен быть последним элементом шаблона. Размещение его в другом месте — ошибка компиляции.

---

### Отсутствие отката

Как только `scanf` потребил входные данные для токена, он не откатывается при неудаче более позднего токена. Если переменная была частично записана, она сохраняет новое значение, а не исходное. На практике это редко создаёт проблемы, но об этом нужно помнить при проектировании шаблонов с пересекающимися возможностями:

```nim
# ХРУПКО: если $* захватит слишком много, буквальное "x" не будет найдено
# и scanf вернёт false, но переменная 'a' уже может быть изменена.
var a, b: string
discard scanf("helloworld", "$*x$+", a, b)
# Безопасный подход: сначала записать во временную переменную, затем проверить
```

---

## `scanTuple` — вариант с возвратом кортежа

```nim
macro scanTuple*(input: untyped; pattern: static[string];
                 matcherTypes: varargs[untyped]): untyped
```

Работает идентично `scanf`, но вместо предварительно объявленных переменных возвращает кортеж. Первый элемент кортежа — `bool`, сигнализирующий об успехе; остальные элементы — захваченные значения, определяемые по типу токенов шаблона.

```nim
let (ok, year, month, day, time) =
  scanTuple("1000-01-01 00:00:00", "$i-$i-$i$s$+")

if ok:
  echo year, "-", month, "-", day   # 1000-1-1
  echo time                          # 00:00:00
```

**Вывод типов:** типы элементов кортежа определяются автоматически из шаблона (`$i` → `int`, `$f` → `float`, `$w`/`$*`/`$+` → `string`, `$c` → `char`).

**Пользовательские матчеры:** если шаблон включает `${yourMatcher()}`, кортеж не может автоматически определить тип захваченного значения. Укажите ожидаемые типы как дополнительные аргументы `scanTuple`:

```nim
let (ok, val) = scanTuple(line, "${myMatcher()}", int)
```

---

## Пользовательские матчеры

Одна из самых мощных возможностей `scanf` — расширяемость с помощью обычных Nim-процедур. Существуют две синтаксические формы:

---

### `${proc}` — матчер с привязкой

```
${имяПроцедуры}
${имяПроцедуры(доп_аргумент1, доп_аргумент2, ...)}
```

Процедура вызывается со входной строкой, переменной для заполнения и текущей позицией. Должна возвращать количество потреблённых символов (0 означает несовпадение).

**Обязательная сигнатура:**

```nim
proc myMatcher(input: string; result: var T; start: int): int
```

где `T` — тип переменной, в которую будет записано захваченное значение.

```nim
proc parseWord(input: string; word: var string; start: int): int =
  result = 0
  while start + result < input.len and input[start + result] != ' ':
    word.add input[start + result]
    inc result
  # возврат 0 означает «нет совпадения»; любое положительное — «потреблено N символов»

var w: string
if scanf("hello world", "${parseWord} world", w):
  echo w   # hello
```

---

### `$[proc]` — матчер-скипер

```
$[имяПроцедуры]
$[имяПроцедуры(доп_аргумент1, доп_аргумент2, ...)]
```

Как `${proc}`, но **не привязывает переменную** — совпавшие символы просто потребляются и отбрасываются. Процедура всё равно возвращает количество потреблённых символов.

**Обязательная сигнатура:**

```nim
proc mySkipper(input: string; start: int): int
# или с дополнительными аргументами:
proc mySkipper(input: string; start: int; extraArg: SomeType): int
```

```nim
proc skipSeps(input: string; start: int;
              seps: set[char] = {':', '-', '.'}): int =
  while start + result < input.len and input[start + result] in seps:
    inc result

var key, value: string
# Пропускаем любую комбинацию ':', '-', '.' между ключом и значением
if scanf("key---value", "$w$[skipSeps]$w", key, value):
  echo key, " -> ", value   # key -> value
```

---

### Передача аргументов матчерам

Дополнительные аргументы можно передавать внутри `{}` или `[]` после имени процедуры. Они добавляются к вызову *после* обязательных аргументов `input`, `result`/`start`.

```nim
proc ndigits(input: string; intVal: var int; start: int; n: int): int =
  ## Соответствует ровно n десятичным цифрам; возвращает 0 если их меньше.
  var x = 0
  var i = 0
  while i < n and i + start < input.len and input[i + start] in {'0'..'9'}:
    x = x * 10 + input[i + start].ord - '0'.ord
    inc i
  if i == n:
    intVal = x
    result = n
  # иначе result остаётся 0 → нет совпадения

var year, month, day: int
# Соответствует ровно yyyy-mm-dd и ничему более
if scanf("2024-03-15", "${ndigits(4)}-${ndigits(2)}-${ndigits(2)}$.",
         year, month, day):
  echo year, month, day   # 2024 3 15
```

---

## `scanp` — грамматический макрос

```nim
macro scanp*(input, idx: typed; pattern: varargs[untyped]): bool
```

Более выразительная альтернатива `scanf`. Вместо строки шаблона `scanp` принимает Nim-выражения с PEG/EBNF-подобными операторами. Изменяет `idx` на месте для отслеживания текущей позиции, что идеально для инкрементального сканирования в цикле.

```nim
var idx = 0
var content = "hello world\nfoo bar\n"
var line = ""
while scanp(content, idx, +(~{'\L', '\0'} -> line.add($_)), '\L'):
  echo line
  line = ""
```

---

### Операторы грамматики

| Синтаксис | Смысл |
|---|---|
| `'c'` | Буквальный символ |
| `{'a'..'z'}` | Символ из набора/диапазона |
| `"str"` | Буквальная строка |
| `(E)` | Группировка |
| `*E` | Ноль или более повторений E |
| `+E` | Одно или более повторений E |
| `?E` | Ноль или одно повторение E (необязательное) |
| `~E` | Отрицательный предикат: успех если E *не* совпадает (не потребляет символы) |
| `E{n,m}` | От `n` до `m` повторений E |
| `E{n}` | Ровно `n` повторений E |
| `a ^* b` | Сокращение для `?(a *(b a))` — список элементов `a`, разделённых `b` (0+) |
| `a ^+ b` | Сокращение для `(a *(b a))` — непустой список элементов `a`, разделённых `b` |
| `E -> action` | Выполнять `action` для каждого символа, потреблённого E |
| `$_` | Внутри действия: текущий совпавший символ |
| `$input` | Внутри действия: вся входная строка |
| `$index` | Внутри действия: текущий индекс во входной строке |
| `имяПроцедуры` | Вызов процедуры как нетерминала (возвращает число потреблённых символов) |

Шаблоны передаются как разделённые запятыми Nim-выражения — запятая играет роль *конкатенации* (последовательности). Все элементы должны совпасть по порядку.

---

### `$_` и привязка действий (`->`)

Инфиксный оператор `->` привязывает *побочное действие* к подвыражению. `$_` внутри действия ссылается на текущий совпавший символ. Именно так символы накапливаются в строке:

```nim
var word = ""
var idx = 0
# Собираем все символы до пробела или конца строки
discard scanp("hello world", idx,
              +(~{' ', '\0'} -> word.add($_)))
echo word   # hello
```

Действий может быть несколько. Действие выполняется по одному разу для каждого символа, потреблённого подвыражением.

---

### Вызов Nim-процедур внутри `scanp`

Обычные Nim-процедуры могут вызываться как *нетерминалы* внутри `scanp`. Сигнатура процедуры должна быть:

```nim
proc myProc(input: InputType; start: int): int
# Возвращает число потреблённых символов, или 0 если нет совпадения
```

При вызове внутри `scanp` результат передаётся встроенному шаблону `success`: любое ненулевое возвращаемое значение — успех, ноль — неудача.

```nim
proc skipUntilHref(s: string; until: string; unless: char; start: int): int =
  # возвращает символы для пропуска, или 0 если `unless` найден первым
  ...

var href = ""
var idx, old = 0
while idx < html.len:
  old = idx
  if scanp(html, idx, "<a",
           skipUntilHref($input, "href=", '>', $index),
           {'\'', '"'},
           *(~{'\'', '"'} -> href.add($_))):
    echo href
    href = ""
  idx = old + 1
```

---

### Пользовательские типы входных данных

По умолчанию `atom` и `nxt` определены для `string`. Вы можете перегрузить эти шаблоны для других типов входных данных (например `Stream`, пользовательский токенизатор), чтобы `scanp` работал с ними:

```nim
import std/streams

template atom(input: Stream; idx: int; c: char): bool =
  peekChar(input) == c

template atom(input: Stream; idx: int; s: set[char]): bool =
  peekChar(input) in s

template nxt(input: Stream; idx: int; step: int = 1) =
  inc(idx, step)
  setPosition(input, idx)
```

---

## Вспомогательные шаблоны для пользовательских типов

Эти шаблоны экспортируются модулем для поддержки пользовательских типов входных данных в `scanp`. Они также используются внутренне строковой реализацией.

### `atom` (перегрузки для string)

```nim
template atom*(input: string; idx: int; c: char): bool
template atom*(input: string; idx: int; s: set[char]): bool
```

Проверяет, совпадает ли символ в позиции `idx` строки `input` с `c` или входит в набор `s`. В конце строки (`idx == input.len`) сопоставляется с `'\0'`. Это примитивы, в которые разворачиваются символьные и множественные литералы в `scanp`.

### `hasNxt`

```nim
template hasNxt*(input: string; idx: int): bool
```

Возвращает `true`, если есть ещё символы для потребления (`idx < input.len`). Используется операторами `*` и `+` в `scanp` для охраны их цикла.

### `nxt`

```nim
template nxt*(input: string; idx: int; step: int = 1)
```

Сдвигает `idx` вперёд на `step` позиций. Вызывается после каждого успешного совпадения атома для перемещения позиции.

### `success`

```nim
template success*(x: int): bool
```

Возвращает `true`, если `x != 0`. Так процедуры-нетерминалы сообщают об успехе `scanp` — процедура возвращает число потреблённых символов, а `success` преобразует это в булево условие.

---

## Совместное использование `scanf` и `scanp`

Два макроса хорошо дополняют друг друга. Распространённый паттерн: использовать `scanp` для итеративного посимвольного сканирования (например, сбора строки-кандидата), а затем применять `scanf` для разбора и валидации структуры этой строки-кандидата:

```nim
iterator parseIps(soup: string): string =
  const digits = {'0'..'9'}
  var a, b, c, d: int
  var buf = ""
  var idx = 0
  while idx < soup.len:
    # scanp: собираем кандидата, похожего на IP-адрес
    if scanp(soup, idx,
             (`digits`{1,3}, '.', `digits`{1,3}, '.',
              `digits`{1,3}, '.', `digits`{1,3}) -> buf.add($_)):
      # scanf: проверяем диапазоны каждого октета
      if buf.scanf("$i.$i.$i.$i", a, b, c, d):
        if a in 0..254 and b in 0..254 and c in 0..254 and d in 0..254:
          yield buf
    buf.setLen(0)
    inc idx
```

---

## Сводная шпаргалка

### Токены шаблона `scanf`

| Токен | Тип захвата | Смысл |
|---|---|---|
| `$i` | `int` | Десятичное целое |
| `$b` | `int` | Двоичное целое |
| `$o` | `int` | Восьмеричное целое |
| `$h` | `int` | Шестнадцатеричное целое |
| `$f` | `float` | Вещественное число |
| `$w` | `string` | ASCII-идентификатор |
| `$c` | `char` | Один символ |
| `$s` | — | Пропуск пробелов (никогда не завершается неудачей) |
| `$$` | — | Буквальный символ `$` |
| `$.` | — | Конец входной строки (должен быть последним) |
| `$*` | `string` | До следующего литерала (0+ символов) |
| `$+` | `string` | До следующего литерала (1+ символов) |
| `${proc}` | зависит | Пользовательский матчер с привязкой |
| `$[proc]` | — | Пользовательский матчер-скипер |

### Операторы `scanp`

| Синтаксис | Смысл |
|---|---|
| `'c'` | Буквальный символ |
| `{'a'..'z'}` | Набор / диапазон символов |
| `"str"` | Буквальная строка |
| `*E` | Ноль или более |
| `+E` | Одно или более |
| `?E` | Необязательное |
| `~E` | Отрицательный предикат |
| `E{n,m}` | От n до m повторений |
| `a ^* b` | Разделённый список (0+) |
| `a ^+ b` | Разделённый список (1+) |
| `E -> action` | Выполнять действие для каждого символа |
| `$_` | Текущий совпавший символ |

### Сигнатуры макросов

```nim
macro scanf*(input: string; pattern: static[string];
             results: varargs[typed]): bool

macro scanTuple*(input: untyped; pattern: static[string];
                 matcherTypes: varargs[untyped]): untyped  # → кортеж

macro scanp*(input, idx: typed; pattern: varargs[untyped]): bool
```

### Сигнатуры пользовательских матчеров

```nim
# Матчер с привязкой — используется с ${имяПроцедуры}
proc myMatcher(input: string; value: var T; start: int): int

# Матчер с привязкой и доп. аргументами — с ${имяПроцедуры(arg1)}
proc myMatcher(input: string; value: var T; start: int; arg1: A): int

# Матчер-скипер — используется с $[имяПроцедуры]
proc mySkipper(input: string; start: int): int

# Нетерминал для scanp
proc myProc(input: string; start: int): int
```

### Ключевые особенности поведения

- Шаблоны — константы времени компиляции; интерпретатора шаблонов в рантайме нет.
- `scanf` по умолчанию выполняет **совпадение с начала**; добавьте `$.` для полного совпадения.
- **Откат отсутствует**: как только входные данные потреблены, они не восстанавливаются при неудаче.
- `scanp` принимает изменяемый `idx` и продвигает его, обеспечивая инкрементальное сканирование в циклах.
- Оба макроса разворачиваются в обычные Nim-вызовы разбора — накладных расходов интерпретатора нет.
